<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ubuntu配置cpp远程连接vs开发环境</title>
      <link href="/2024/01/11/tips/ubuntu%E9%85%8D%E7%BD%AEcpp%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5vs%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2024/01/11/tips/ubuntu%E9%85%8D%E7%BD%AEcpp%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5vs%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-ubuntu-首次设置root密码"><a href="#1-ubuntu-首次设置root密码" class="headerlink" title="1.ubuntu 首次设置root密码"></a>1.ubuntu 首次设置root密码</h3><p>切换到root用户身份：sudo -i</p><p>系统会要求输入当前用户的密码，然后按Enter确认。</p><p>接下来，使用以下命令设置root用户的新密码：passwd root</p><p>系统将提示您输入新的root密码两次，并显示成功更改密码的消息。</p><p>现在，您已经完成了对root用户的首次设置。</p><h3 id="2-ubuntu-配置ssh连接"><a href="#2-ubuntu-配置ssh连接" class="headerlink" title="2.ubuntu 配置ssh连接"></a>2.ubuntu 配置ssh连接</h3><p>安装net服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt install net-tools</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install openssh-server</span><br></pre></td></tr></table></figure><p>修改配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apt install vim</span><br><span class="line">sudo vim</span><br><span class="line">命令：sudo vim /etc/ssh/sshd_config</span><br><span class="line">找到 #PermitRootLogin prohibit-password</span><br><span class="line">改为 PermitRootLogin yes</span><br><span class="line">重启ssh服务</span><br><span class="line">sudo systemctl restart ssh</span><br></pre></td></tr></table></figure><h3 id="3-虚拟机设置静态ip"><a href="#3-虚拟机设置静态ip" class="headerlink" title="3.虚拟机设置静态ip"></a>3.虚拟机设置静态ip</h3><p>nat模式 手动分配ip  前三个四字节与主机相同 后一个随便，与主机、网关不同即可。网关前三个四字节与主机相同后一个四字节为2。例<br>192.168.187.1   主机ip<br>192.168.187.2   虚拟机网关<br>192.168.187.3   虚拟机手动设置ip</p><h3 id="4-ubuntu安装mysql并配置"><a href="#4-ubuntu安装mysql并配置" class="headerlink" title="4.ubuntu安装mysql并配置"></a>4.ubuntu安装mysql并配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt-get upgrade #更新</span><br><span class="line">apt-get update  </span><br><span class="line">#安装mysql</span><br><span class="line">apt-get install mysql-server</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="设置root密码"><a href="#设置root密码" class="headerlink" title="设置root密码"></a>设置root密码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">将root用户的密码认证方式从&quot;mysql_native_password&quot;更改为&quot;caching_sha2_password&quot;，则需要使用以下命令：</span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH caching_sha2_password BY &#x27;&lt;新密码&gt;&#x27;;</span><br><span class="line">flush privileges;</span><br><span class="line">update user set host=&#x27;%&#x27; where user=&#x27;root&#x27;;</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="配置可访问ip"><a href="#配置可访问ip" class="headerlink" title="配置可访问ip"></a>配置可访问ip</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</span><br><span class="line">在 bind-address=127.0.0.1 前加 # 注释</span><br><span class="line">保存关闭文件</span><br><span class="line">重启mysql，可能需要填入系统认证信息</span><br><span class="line">service mysql restart</span><br><span class="line">配置MySQL开机自启</span><br><span class="line">sudo update-rc.d mysql defaults</span><br><span class="line"></span><br><span class="line">安装mysqlclientc++(C++的一个链接器)</span><br><span class="line">sudo apt-get install libmysqlcppconn-dev</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考<br><a href="https://blog.csdn.net/weixin_43571107/article/details/129271752">https://blog.csdn.net/weixin_43571107/article/details/129271752</a></p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一种windows线程池写法</title>
      <link href="/2023/10/17/CPP/%E4%B8%80%E7%A7%8Dwindows%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%86%99%E6%B3%95/"/>
      <url>/2023/10/17/CPP/%E4%B8%80%E7%A7%8Dwindows%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%86%99%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/source/_posts/CPP/%E4%B8%80%E7%A7%8Dwindows%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%86%99%E6%B3%95/windowsThreadPool.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line">class ThreadFuncBase &#123;&#125;;</span><br><span class="line">class Thread;</span><br><span class="line">class ThreadWorker;</span><br><span class="line">class EdoyunThreadPool;</span><br><span class="line">typedef int (ThreadFuncBase::* FUNCTYPE)();</span><br><span class="line">class Thread &#123;  </span><br><span class="line">private:</span><br><span class="line">    HANDLE m_hThread;</span><br><span class="line">    bool m_bStatus; // false 表示线程将要关闭 true 表示线程正在运行</span><br><span class="line">    std::atomic&lt;::ThreadWorker*&gt; m_worker;</span><br><span class="line">    void ThreadWorker() &#123;</span><br><span class="line">        while (m_bStatus) &#123;</span><br><span class="line">            if (m_worker.load() == NULL) &#123;</span><br><span class="line">                Sleep(1);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            ::ThreadWorker worker = *m_worker.load();</span><br><span class="line">            if (worker.IsValid()) &#123;</span><br><span class="line">                if (WaitForSingleObject(m_hThread, 0) == WAIT_TIMEOUT) &#123;</span><br><span class="line">                    int ret = worker();</span><br><span class="line">                    if (ret != 0) &#123;</span><br><span class="line">                        printf(&quot;thread found warning code %d\r\n&quot;, ret);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (ret &lt; 0) &#123;</span><br><span class="line">                        ::ThreadWorker* pWorker = m_worker.load();</span><br><span class="line">                        m_worker.store(NULL);</span><br><span class="line">                        delete pWorker;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                Sleep(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static void ThreadEntry(void* arg) &#123;</span><br><span class="line">        Thread* thiz = (Thread*)arg;</span><br><span class="line">        if (thiz) &#123;</span><br><span class="line">            thiz-&gt;ThreadWorker();</span><br><span class="line">        &#125;</span><br><span class="line">        _endthread();</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    Thread() &#123;</span><br><span class="line">        m_hThread = NULL;</span><br><span class="line">        m_bStatus = false;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Thread() &#123;</span><br><span class="line">        Stop();</span><br><span class="line">    &#125;</span><br><span class="line">    //true 成功 false shibai</span><br><span class="line">    bool Start() &#123;</span><br><span class="line">        m_bStatus = true;</span><br><span class="line">        m_hThread = (HANDLE)_beginthread(&amp;Thread::ThreadEntry, 0, this);</span><br><span class="line">        if (!IsValid()) &#123;</span><br><span class="line">            m_bStatus = false;</span><br><span class="line">        &#125;</span><br><span class="line">        return m_bStatus;</span><br><span class="line">    &#125;</span><br><span class="line">    bool IsValid() &#123; //返回true表示有效，false表示线程异常或者已经终止</span><br><span class="line">        if (m_hThread == NULL || (m_hThread == INVALID_HANDLE_VALUE)) return false;</span><br><span class="line">        return WaitForSingleObject(m_hThread, 0) == WAIT_TIMEOUT;</span><br><span class="line">    &#125;</span><br><span class="line">    bool Stop() &#123;</span><br><span class="line">        if (m_bStatus == false) return true;</span><br><span class="line">        m_bStatus = false;</span><br><span class="line">        DWORD ret = WaitForSingleObject(m_hThread, 1000);</span><br><span class="line">        if (ret == WAIT_TIMEOUT) &#123;</span><br><span class="line">            TerminateThread(m_hThread, -1);</span><br><span class="line">        &#125;</span><br><span class="line">        UpdateWorker();</span><br><span class="line">        return ret == WAIT_OBJECT_0;</span><br><span class="line">    &#125;</span><br><span class="line">    void UpdateWorker(const ::ThreadWorker&amp; worker = ::ThreadWorker()) &#123;</span><br><span class="line">        if (m_worker.load() != NULL &amp;&amp; (m_worker.load() != &amp;worker)) &#123;</span><br><span class="line">            ::ThreadWorker* pWorker = m_worker.load();</span><br><span class="line">            printf(&quot; delete pWorker = %08X m_worker = %08X\r\n&quot;, pWorker, m_worker.load());</span><br><span class="line">            m_worker.store(NULL);</span><br><span class="line">            delete pWorker;</span><br><span class="line">        &#125;</span><br><span class="line">        if (m_worker.load() == &amp;worker) return;</span><br><span class="line">        if (!worker.IsValid()) &#123;</span><br><span class="line">            m_worker.store(NULL);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        ::ThreadWorker* pWorker = new ::ThreadWorker(worker);</span><br><span class="line">        printf(&quot;new pWorker = %08X m_worker = %08X\r\n&quot;, pWorker, m_worker.load());</span><br><span class="line">        m_worker.store(pWorker);</span><br><span class="line">    &#125;</span><br><span class="line">    //true表示空闲 false表示已经分配了工作</span><br><span class="line">    bool IsIdle() &#123;</span><br><span class="line">        if (m_worker.load() == NULL) return false;</span><br><span class="line">        return !m_worker.load()-&gt;IsValid();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ThreadWorker &#123;</span><br><span class="line">private:</span><br><span class="line">    ThreadFuncBase* thiz;</span><br><span class="line">    FUNCTYPE func;</span><br><span class="line">public:</span><br><span class="line">    ThreadWorker() :thiz(NULL), func(NULL) &#123;&#125;</span><br><span class="line">    ThreadWorker(void* obj, FUNCTYPE f) :thiz((ThreadFuncBase*)obj), func(f) &#123;&#125;</span><br><span class="line">    ThreadWorker(const ThreadWorker&amp; worker) &#123;</span><br><span class="line">        thiz = worker.thiz;</span><br><span class="line">        func = worker.func;</span><br><span class="line">    &#125;</span><br><span class="line">    ThreadWorker operator = (const ThreadWorker&amp; worker) &#123;</span><br><span class="line">        if (this != &amp;worker) &#123;</span><br><span class="line">            thiz = worker.thiz;</span><br><span class="line">            func = worker.func;</span><br><span class="line">        &#125;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    int operator()() &#123;</span><br><span class="line">        if (thiz) &#123;</span><br><span class="line">            return (thiz-&gt;*func)();</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    bool IsValid() const &#123;</span><br><span class="line">        return (thiz != NULL) &amp;&amp; (func != NULL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class EdoyunThreadPool &#123;</span><br><span class="line">private:</span><br><span class="line">    std::mutex m_lock;</span><br><span class="line">    std::vector&lt;Thread*&gt; m_threads;</span><br><span class="line">public:</span><br><span class="line">    EdoyunThreadPool(size_t size) &#123;</span><br><span class="line">        m_threads.resize(size);</span><br><span class="line">        for (size_t i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            m_threads[i] = new Thread();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    EdoyunThreadPool() &#123;</span><br><span class="line">        Stop();</span><br><span class="line">        for (size_t i = 0; i &lt; m_threads.size(); i++) &#123;</span><br><span class="line">            delete m_threads[i];</span><br><span class="line">            m_threads[i] = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        m_threads.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    ~EdoyunThreadPool() &#123;&#125;</span><br><span class="line">    bool Invoke() &#123;</span><br><span class="line">        bool ret = true;</span><br><span class="line">        for (size_t i = 0; i &lt; m_threads.size(); i++) &#123;</span><br><span class="line">            if (m_threads[i]-&gt;Start() == false) &#123;</span><br><span class="line">                ret = false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (ret == false) &#123;</span><br><span class="line">            for (size_t i = 0; i &lt; m_threads.size(); i++) &#123;</span><br><span class="line">                m_threads[i]-&gt;Stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    void Stop() &#123;</span><br><span class="line">        for (size_t i = 0; i &lt; m_threads.size(); i++) &#123;</span><br><span class="line">            m_threads[i]-&gt;Stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //返回-1表示分配失败，所有线程都在忙，大于等于0，表示第n个线程分配来做这个事情</span><br><span class="line">    int DispatchWorker(const ThreadWorker&amp; worker) &#123;</span><br><span class="line">        int index = -1;</span><br><span class="line">        m_lock.lock();</span><br><span class="line">        for (size_t i = 0; i &lt; m_threads.size(); i++) &#123;</span><br><span class="line">            if (m_threads[i]-&gt;IsIdle()) &#123;</span><br><span class="line">                m_threads[i]-&gt;UpdateWorker(worker);</span><br><span class="line">                index = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        m_lock.unlock();</span><br><span class="line">        return index;</span><br><span class="line">    &#125;</span><br><span class="line">    bool CheckThreadValid(int index) &#123;</span><br><span class="line">        int m_threads_size = m_threads.size();</span><br><span class="line">        if (index &lt; m_threads_size) &#123;</span><br><span class="line">            //adds</span><br><span class="line">            return m_threads[index]-&gt;IsValid();</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>完成端口（iocp）</title>
      <link href="/2023/10/16/CPP/IO%E5%AE%8C%E6%88%90%E7%AB%AF%E5%8F%A3%EF%BC%88iocp%EF%BC%89/"/>
      <url>/2023/10/16/CPP/IO%E5%AE%8C%E6%88%90%E7%AB%AF%E5%8F%A3%EF%BC%88iocp%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iocp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp原子变量atomic详解</title>
      <link href="/2023/10/13/CPP/cpp%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8Fatomic%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/10/13/CPP/cpp%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8Fatomic%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="C-原子变量atomic详解"><a href="#C-原子变量atomic详解" class="headerlink" title="C++原子变量atomic详解"></a>C++原子变量atomic详解</h1><p>参考列表：<a href="https://zhuanlan.zhihu.com/p/599202353">https://zhuanlan.zhihu.com/p/599202353</a> <a href="https://cplusplus.com/reference/atomic/atomic/">https://cplusplus.com/reference/atomic/atomic/</a><br><a href="https://blog.csdn.net/sinat_28305511/article/details/131257757">https://blog.csdn.net/sinat_28305511/article/details/131257757</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>C++中原子变量（atomic）是一种多线程编程中常用的同步机制，它能够确保对共享变量的操作在执行时不会被其他线程的操作干扰，从而避免竞态条件（race condition）和死锁（deadlock）等问题。</p><p>原子变量可以看作是一种特殊的类型，它具有类似于普通变量的操作，但是这些操作都是原子级别的，即要么全部完成，要么全部未完成。C++标准库提供了丰富的原子类型，包括整型、指针、布尔值等，使用方法也非常简单，只需要通过std::atomic&lt;T&gt;定义一个原子变量即可，其中T表示变量的类型。</p><p>在普通的变量中，并发的访问它可能会导致数据竞争，竞争的后果会导致操作过程不会按照正确的顺序进行操作。</p><p>atomic对象可以通过指定不同的memory orders来控制其对其他非原子对象的访问顺序和可见性，从而实现线程安全。常用的memory orders包括：<br>memory_order_relaxed、<br>memory_order_acquire、<br>memory_order_release、<br>memory_order_acq_rel<br>memory_order_seq_cst等。</p><h3 id="C-6种内存序"><a href="#C-6种内存序" class="headerlink" title="C++ 6种内存序"></a>C++ 6种内存序</h3><p>在多线程编程中，内存序可以帮助我们更好地控制多线程程序中的数据访问顺序。C++ 11引入了6种内存序，分别是 <code>memory_order_relaxed</code>、<code>memory_order_consume</code>、<code>memory_order_acquire</code>、<code>memory_order_release</code>、<code>memory_order_acq_rel</code> 和 <code>memory_order_seq_cst</code>。这些内存序提供了不同级别的同步保证，可以帮助我们在多线程程序中实现更精细的控制。</p><ul><li><code>memory_order_relaxed</code>: 最宽松的内存序，不提供任何同步保证。它只保证原子操作本身是原子的，但不保证操作之间的顺序。</li><li><code>memory_order_consume</code>: 消费者内存序，用于同步依赖关系。它保证了依赖于原子操作结果的后续操作将按照正确的顺序执行。</li><li><code>memory_order_acquire</code>: 获取内存序，用于同步对共享数据的访问。它保证了在获取操作之后对共享数据的所有读取操作都将看到最新的数据。</li><li><code>memory_order_release</code>: 释放内存序，用于同步对共享数据的访问。它保证了在释放操作之前对共享数据的所有写入操作都已完成，并且对其他线程可见。</li><li><code>memory_order_acq_rel</code>: 获取-释放内存序，结合了获取和释放两种内存序的特点。它既保证了获取操作之后对共享数据的所有读取操作都将看到最新的数据，又保证了在释放操作之前对共享数据的所有写入操作都已完成，并且对其他线程可见。</li><li><code>memory_order_seq_cst</code>: 顺序一致性内存序，提供了最严格的同步保证。它保证了所有线程都将看到相同的操作顺序，并且所有原子操作都将按照程序顺序执行。</li></ul><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>std::atomic::atomic</p><blockquote><p>（1）默认：使对象处于未初始化状态。 atomic() noexcept &#x3D; default;   <br><br>（2）初始化 ：使用val初始化对象。 constexpratomic (T val) noexcept; <br><br>（3）复制 [删除] ：无法复制&#x2F;移动对象。 atomic (const atomic&amp;) &#x3D; delete;</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::atmoic&lt;int&gt; count(0);</span><br></pre></td></tr></table></figure><h3 id="is-lock-free函数"><a href="#is-lock-free函数" class="headerlink" title="is_lock_free函数"></a>is_lock_free函数</h3><p>is_lock_free用于检查当前atomic对象是否支持无锁操作，调用此成员函数不会启动任何数据竞争</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool is_lock_free() const volatile noexcept;</span><br><span class="line">bool is_lock_free() const noexcept;</span><br></pre></td></tr></table></figure><h4 id="std-atomic-flag"><a href="#std-atomic-flag" class="headerlink" title="std::atomic_flag"></a>std::atomic_flag</h4><p>std::atomic_flag 是 C++ 中的一个原子布尔类型，它用于实现原子锁操作。</p><ol><li>std::atomic_flag 默认是清除状态（false）。可以使用 ATOMIC_FLAG_INIT 宏进行初始化，例如：<code>std::atomic_flag flag = ATOMIC_FLAG_INIT</code>;</li><li>std::atomic_flag 提供了两个成员函数 test_and_set() 和 clear() 来测试和设置标志位。test_and_set() 函数会将标志位置为 true，并返回之前的值；clear() 函数将标志位置为 false。</li><li>std::atomic_flag 的 test_and_set() 和 clear() 操作是原子的，可以保证在多线程环境下正确执行。</li><li>std::atomic_flag 只能表示两种状态，即 true 或 false，不能做其他比较操作。通常情况下，std::atomic_flag 被用作简单的互斥锁，而不是用来存储信息</li></ol><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;atomic&gt;</span><br><span class="line">#include&lt;thread&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">std::atomic_flag flag = ATOMIC_FLAG_INIT; //初始状态为false</span><br><span class="line">void func(int id) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Thread  &quot; &lt;&lt; id &lt;&lt; &quot; start func&quot; &lt;&lt; std::endl;</span><br><span class="line">    while (flag.test_and_set(std::memory_order_acquire)) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Thread &quot;&lt;&lt; id &lt;&lt;&quot; is waiting&quot; &lt;&lt; std::endl;</span><br><span class="line">        // 等待其他线程释放锁</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; &quot; acquired the lock.&quot; &lt;&lt; std::endl;</span><br><span class="line">    // 模拟业务处理</span><br><span class="line">    //std::this_thread::sleep_for(std::chrono::seconds(1));</span><br><span class="line">    flag.clear(std::memory_order_release);  // 释放锁</span><br><span class="line">    std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; &quot; released the lock.&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">void _test() &#123;</span><br><span class="line">    std::cout &lt;&lt; flag.test_and_set(std::memory_order_acquire) &lt;&lt; std::endl;</span><br><span class="line">    flag.clear();</span><br><span class="line">    std::cout &lt;&lt; flag.test_and_set(std::memory_order_acquire) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; flag.test_and_set(std::memory_order_acquire) &lt;&lt; std::endl;</span><br><span class="line">    //set后状态为true</span><br><span class="line">    flag.clear();</span><br><span class="line">    std::thread t1(func, 1);</span><br><span class="line">    std::thread t2(func, 2);</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">Thread  Thread  2 start func</span><br><span class="line">Thread 2 acquired the lock.</span><br><span class="line">Thread 2 released the lock.</span><br><span class="line">1 start func</span><br><span class="line">Thread 1 acquired the lock.</span><br><span class="line">Thread 1 released the lock.</span><br></pre></td></tr></table></figure><p>两个线程通过 std::atomic_flag 来争夺一个资源（即打印信息），只有一个线程能够获得锁，执行相应的操作。另一个线程需要等待锁被释放才能继续执行。使用test_and_set() 和 clear() 函数来测试和设置标志位，保证这些操作是原子的。</p><h3 id="store函数"><a href="#store函数" class="headerlink" title="store函数"></a>store函数</h3><p>std::atomic<T>::store()用于将给定的值存储到原子对象中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void store(T desired, std::memory_order order = std::memory_order_seq_cst) volatile noexcept;</span><br><span class="line">void store(T desired, std::memory_order order = std::memory_order_seq_cst) noexcept;</span><br></pre></td></tr></table></figure><ul><li><code>desired</code>：要存储的值。</li><li><code>order</code>：存储操作的内存顺序。默认是std::memory_order_seq_cst（顺序一致性）</li></ul><p>存储操作的内存顺序参数：</p><table><thead><tr><th>value</th><th>内存顺序</th><th>描述</th></tr></thead><tbody><tr><td>memory_order_relaxed</td><td>无序的内存访问</td><td>不做任何同步，仅保证该原子类型变量的操作是原子化的，并不保证其对其他线程的可见性和正确性。</td></tr><tr><td>memory_order_consume</td><td>与消费者关系有关的顺序</td><td>保证本次读取之前所有依赖于该原子类型变量值的操作都已经完成，但不保证其他线程对该变量的存储结果已经可见。</td></tr><tr><td>memory_order_acquire</td><td>获取关系的顺序</td><td>保证本次读取之前所有先于该原子类型变量写入内存的操作都已经完成，并且其他线程对该变量的存储结果已经可见。</td></tr><tr><td>memory_order_seq_cst</td><td>顺序一致性的顺序</td><td>保证本次操作以及之前和之后的所有原子操作都按照一个全局的内存顺序执行，从而保证多线程环境下对变量的读写的正确性和一致性。这是最常用的内存顺序。</td></tr><tr><td>memory_order_release</td><td>释放关系的顺序</td><td>保证本次写入之后所有后于该原子类型变量写入内存的操作都已经完成，并且其他线程可以看到该变量的存储结果。</td></tr><tr><td><em>详见简介 C++6种内存序</em></td><td></td><td></td></tr><tr><td>示例</td><td></td><td></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;int&gt; atomic_int(0);</span><br><span class="line">std::cout &lt;&lt; &quot;Value stored in atomic object: &quot; &lt;&lt; atomic_int &lt;&lt; std::endl;</span><br><span class="line">int val = 10;</span><br><span class="line">atomic_int.store(val); //默认memory_order_seq_cst 顺序一致性</span><br><span class="line">std::cout &lt;&lt; &quot;Value stored in atomic object: &quot; &lt;&lt; atomic_int &lt;&lt; std::endl;</span><br><span class="line">val = 5;</span><br><span class="line">atomic_int.store(val);</span><br><span class="line">std::cout &lt;&lt; &quot;Value stored in atomic object: &quot; &lt;&lt; atomic_int &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Value stored in atomic object: 0</span><br><span class="line">Value stored in atomic object: 10</span><br><span class="line">Value stored in atomic object: 5</span><br></pre></td></tr></table></figure><p>在多线程环境下使用原子变量和操作时，需要使用适当的内存顺序来保证数据的正确性和一致性。因此，store()函数中的order参数可以用来指定不同的内存顺序。如果不确定如何选择内存顺序，请使用默认值std::memory_order_seq_cst，它是最常用和最保险的。</p><h3 id="load函数"><a href="#load函数" class="headerlink" title="load函数"></a>load函数</h3><p>load函数用于获取原子变量的当前值。它有以下两种形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T load(memory_order order = memory_order_seq_cst) const noexcept;</span><br><span class="line">operator T() const noexcept;</span><br></pre></td></tr></table></figure><p>其中，第一种形式是显式调用load函数，第二种形式是通过重载类型转换运算符实现隐式调用。</p><p>load函数的参数memory_order表示内存序，也就是对原子变量的读操作要遵循哪种内存模型。C++中定义了多种内存序，包括：</p><ul><li>memory_order_relaxed：最轻量级的内存序，不提供任何同步机制。</li><li>memory_order_acquire：在本线程中，所有后面的读写操作必须在这个操作之后执行。</li><li>memory_order_release：在本线程中，该操作之前的所有读写操作必须在这个操作之前执行。 </li><li>memory_order_seq_cst：最严格的内存序，保证所有线程看到的读写操作的顺序都是一致的。</li></ul><p>使用load函数时，如果不指定memory_order，则默认为memory_order_seq_cst。 <br><br>load函数的返回值类型为T，即原子变量的类型。在使用load函数时需要指定类型参数T。如果使用第二种形式的load函数，则无需指定类型参数T，程序会自动根据上下文推断出类型。</p><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;int&gt; atomic_int(10);</span><br><span class="line">int x = atomic_int.load(std::memory_order_relaxed); // get value atomically</span><br><span class="line">int xx = int(atomic_int.load());</span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; xx &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h3 id="exchange函数"><a href="#exchange函数" class="headerlink" title="exchange函数"></a>exchange函数</h3><p>访问和修改包含的值，将包含的值替换并返回它前面的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt; class T &gt;</span><br><span class="line">T exchange( volatile std::atomic&lt;T&gt;* obj, T desired );</span><br></pre></td></tr></table></figure><p>其中，obj参数指向需要替换值的atomic对象，desired参数为期望替换成的值。如果替换成功，则返回原来的值。</p><p>整个操作是原子的（原子读-修改-写操作）：从读取（要返回）值的那一刻到此函数修改值的那一刻，该值不受其他线程的影响。<br>用例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">std::atomic&lt;bool&gt; ready(false);</span><br><span class="line">std::atomic&lt;bool&gt; winner(false);</span><br><span class="line">void count1m(int id) &#123;</span><br><span class="line">    while (!ready) &#123;&#125;                  // wait for the ready signal</span><br><span class="line">    for (int i = 0; i &lt; 1000000; ++i) &#123;&#125;   // go!, count to 1 million</span><br><span class="line">    if (!winner.exchange(true)) &#123; std::cout &lt;&lt; &quot;thread #&quot; &lt;&lt; id &lt;&lt; &quot; won!\n&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void _test() &#123;</span><br><span class="line">    //exchange</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    std::cout &lt;&lt; &quot;spawning 10 threads that count to 1 million...\n&quot;;</span><br><span class="line">    for (int i = 1; i &lt;= 10; ++i) threads.push_back(std::thread(count1m, i));</span><br><span class="line">    ready = true;</span><br><span class="line">    for (auto&amp; th : threads) th.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread #6 won!</span><br></pre></td></tr></table></figure><h3 id="compare-exchange-weak函数"><a href="#compare-exchange-weak函数" class="headerlink" title="compare_exchange_weak函数"></a>compare_exchange_weak函数</h3><p>这个函数的作用是比较一个值和一个期望值是否相等，如果相等则将该值替换成一个新值，并返回true；否则不做任何操作并返回false。</p><blockquote><p>bool compare_exchange_weak (T&amp; expected, T val,memory_order sync &#x3D; memory_order_seq_cst) volatile noexcept;<br>bool compare_exchange_weak (T&amp; expected, T val,memory_order sync &#x3D; memory_order_seq_cst) noexcept;<br>bool compare_exchange_weak (T&amp; expected, T val,memory_order success, memory_order failure) volatile noexcept;<br>bool compare_exchange_weak (T&amp; expected, T val,memory_order success, memory_order failure) noexcept;</p></blockquote><p>参数说明</p><ul><li>expected：期望值的地址，也是输入参数，表示要比较的值；</li><li>val：新值，也是输入参数，表示期望值等于该值时需要替换的值；</li><li>success：表示函数执行成功时内存序的类型，默认为memory_order_seq_cst；</li><li>failure：表示函数执行失败时内存序的类型，默认为memory_order_seq_cst。</li></ul><p>该函数的返回值为bool类型，表示操作是否成功。</p><p>注意，compare_exchange_weak函数是一个弱化版本的原子操作函数，因为在某些平台上它可能会失败并重试。如果需要保证严格的原子性，则应该使用compare_exchange_strong函数。<br>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;       // std::cout</span><br><span class="line">#include &lt;atomic&gt;         // std::atomic</span><br><span class="line">#include &lt;thread&gt;         // std::thread</span><br><span class="line">#include &lt;vector&gt;         // std::vector</span><br><span class="line"></span><br><span class="line">// a simple global linked list:</span><br><span class="line">struct Node &#123; int value; Node* next; &#125;;</span><br><span class="line">std::atomic&lt;Node*&gt; list_head (nullptr);</span><br><span class="line"></span><br><span class="line">void append (int val) &#123;     // append an element to the list</span><br><span class="line">  Node* oldHead = list_head;</span><br><span class="line">  Node* newNode = new Node &#123;val,oldHead&#125;;</span><br><span class="line"></span><br><span class="line">  // what follows is equivalent to: list_head = newNode, but in a thread-safe way:</span><br><span class="line">  while (!list_head.compare_exchange_weak(oldHead,newNode))</span><br><span class="line">    newNode-&gt;next = oldHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">  // spawn 10 threads to fill the linked list:</span><br><span class="line">  std::vector&lt;std::thread&gt; threads;</span><br><span class="line">  for (int i=0; i&lt;10; ++i) threads.push_back(std::thread(append,i));</span><br><span class="line">  for (auto&amp; th : threads) th.join();</span><br><span class="line"></span><br><span class="line">  // print contents:</span><br><span class="line">  for (Node* it = list_head; it!=nullptr; it=it-&gt;next)</span><br><span class="line">    std::cout &lt;&lt; &#x27; &#x27; &lt;&lt; it-&gt;value;</span><br><span class="line">  std::cout &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line"></span><br><span class="line">  // cleanup:</span><br><span class="line">  Node* it; while (it=list_head) &#123;list_head=it-&gt;next; delete it;&#125;</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="compare-exchange-strong函数"><a href="#compare-exchange-strong函数" class="headerlink" title="compare_exchange_strong函数"></a>compare_exchange_strong函数</h3><p>这个函数的作用和compare_exchange_weak类似，都是比较一个值和一个期望值是否相等，并且在相等时将该值替换成一个新值。不同的是，compare_exchange_strong会保证原子性，并且如果比较失败则会返回当前值。</p><blockquote><p>bool compare_exchange_strong(T&amp; expected, T desired,<br>                             memory_order success &#x3D; memory_order_seq_cst,<br>                             memory_order failure &#x3D; memory_order_seq_cst) noexcept;</p></blockquote><ul><li>expected：期望值的地址，也是输入参数，表示要比较的值；</li><li>desired：新值，也是输入参数，表示期望值等于该值时需要替换的值；</li><li>success：表示函数执行成功时内存序的类型，默认为memory_order_seq_cst；</li><li>failure：表示函数执行失败时内存序的类型，默认为memory_order_seq_cst。</li></ul><p>该函数的返回值为bool类型，表示操作是否成功。</p><p>注意，compare_exchange_strong函数保证原子性，因此它的效率可能比compare_exchange_weak低。在使用时应根据具体情况选择适合的函数。</p><h3 id="专业化支持的操作"><a href="#专业化支持的操作" class="headerlink" title="专业化支持的操作"></a>专业化支持的操作</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>fetch_add</td><td>添加到包含的值并返回它在操作之前具有的值</td></tr><tr><td>fetch_sub</td><td>从包含的值中减去，并返回它在操作之前的值</td></tr><tr><td>fetch_and</td><td>读取包含的值，并将其替换为在读取值和 之间执行按位 AND 运算的结果</td></tr><tr><td>fetch_or</td><td>读取包含的值，并将其替换为在读取值和 之间执行按位 OR 运算的结果</td></tr><tr><td>fetch_xor</td><td>读取包含的值，并将其替换为在读取值和 之间执行按位 XOR 运算的结果</td></tr><tr><td>使用示例</td><td></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// atomic::load/store example</span><br><span class="line">#include &lt;iostream&gt; // std::cout</span><br><span class="line">#include &lt;atomic&gt; // std::atomic, std::memory_order_relaxed</span><br><span class="line">#include &lt;thread&gt; // std::thread</span><br><span class="line">//std::atomic&lt;int&gt; count = 0;//错误初始化</span><br><span class="line">std::atomic&lt;int&gt; count(0); // 准确初始化</span><br><span class="line">void set_count(int x)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; &quot;set_count:&quot; &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">count.store(x, std::memory_order_relaxed); // set value atomically</span><br><span class="line">&#125;</span><br><span class="line">void print_count()</span><br><span class="line">&#123;</span><br><span class="line">int x;</span><br><span class="line">do &#123;</span><br><span class="line">x = count.load(std::memory_order_relaxed); // get value atomically</span><br><span class="line">&#125; while (x==0);</span><br><span class="line">std::cout &lt;&lt; &quot;count: &quot; &lt;&lt; x &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">std::thread t1 (print_count);</span><br><span class="line">std::thread t2 (set_count, 10);</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line">std::cout &lt;&lt; &quot;main finish\n&quot;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>原子操作在多线程中可以保证线程安全，而且效率会比互斥量好些。</p><p>原子变量支持的基本操作有：</p><ul><li>加法：a +&#x3D; n或者a.fetch_add(n)</li><li>减法：a -&#x3D; n或者a.fetch_sub(n)</li><li>与、或、异或运算：a &amp;&#x3D; b、a |&#x3D; b、a ^&#x3D; b或者a.fetch_and(b)、a.fetch_or(b)、a.fetch_xor(b)</li><li>自增、自减运算：++a、–a、a++、a–或者a.fetch_add(1)、a.fetch_sub(1)</li><li>交换：a.exchange(b)返回原来的值，将a设置为b</li><li>比较并交换：a.compare_exchange_strong(b, c)或者a.compare_exchange_weak(b, c)，如果a的值等于b，则将a设置为c，返回true，否则返回false。</li></ul><p>尽管原子变量是多线程编程中非常重要的同步机制，但是它也存在一些局限性。具体来说，原子变量只能保证单个变量的原子性操作，而不能保证多个变量之间的同步。此外，原子变量也无法解决数据竞争（data race）等问题，因此在使用时需要注意避免这些问题的出现。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> atomic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker入门</title>
      <link href="/2023/08/11/tips/docker%E5%85%A5%E9%97%A8/"/>
      <url>/2023/08/11/tips/docker%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="docker入门教程"><a href="#docker入门教程" class="headerlink" title="docker入门教程"></a>docker入门教程</h1><blockquote><p>演示视频：<br><a href="https://www.bilibili.com/video/BV1Kg411D78F/">https://www.bilibili.com/video/BV1Kg411D78F/</a></p></blockquote><blockquote><p>文档地址：<br><a href="https://www.yuque.com/wukong-zorrm/xwas40/">https://www.yuque.com/wukong-zorrm/xwas40/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux C++ 多线程</title>
      <link href="/2023/07/25/CPP/LinuxC++%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/07/25/CPP/LinuxC++%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="线程是-CPU-调度和分派的基本单位"><a href="#线程是-CPU-调度和分派的基本单位" class="headerlink" title="线程是 CPU 调度和分派的基本单位"></a>线程是 CPU 调度和分派的基本单位</h3><p>是处于执行期的程序以及它所管理的资源（如打开的文件、挂起的信号、进程状态、地址空间等等）的总称，从操作系统核心角度来说，进程是操作系统调度除 CPU 时间片外进行的资源分配和保护的基本单位，它有一个独立的虚拟地址空间，用来容纳进程映像(如与进程关联的程序与数据)，并以进程为单位对各种资源实施保护，如受保护地访问处理器、文件、外部设备及其他进程(进程间通信)<br><br><br>进程拥有独立的地址空间（包括数据区、堆区和栈区）。而线程拥有独立的栈区域，数据区和堆区都是一个进程中的几个线程共享的。</p><h3 id="为什么要使用多线程"><a href="#为什么要使用多线程" class="headerlink" title="为什么要使用多线程"></a>为什么要使用多线程</h3><ol><li>避免阻塞</li><li>避免 CPU 空转</li><li>提升效率</li></ol><h2 id="线程的创建与运行"><a href="#线程的创建与运行" class="headerlink" title="线程的创建与运行"></a>线程的创建与运行</h2><h3 id="pthread-create："><a href="#pthread-create：" class="headerlink" title="pthread_create："></a>pthread_create：</h3><p>线程具有单独的执行流，因此需要单独定义线程的 main 函数，还需要请求操作系统在单独的执行流中执行该函数，完成该功能的函数如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;pthread.h&gt;    </span><br><span class="line">int pthread_create(     </span><br><span class="line">pthread_t* restrict thread,  </span><br><span class="line">const pthread_attr_t* restrict attr,    </span><br><span class="line">void *( *start_routine)(void *),    </span><br><span class="line">void* restrict arg ); </span><br></pre></td></tr></table></figure><p>→成功时返回 0，失败时返回其他值。</p><ul><li>thread<br>保存新创建线程 ID 的变量地址值。线程与进程相同，也需要用于区分不同线程的 ID。</li><li>attr<br>用于传递线程属性的参数，传递 NULL 时，创建默认属性的线程。</li><li>start routine<br>相当于线程 main 函数的、在单独执行流中执行的函数地址值（函数指针）。</li><li>arg<br>通过第三个参数传递调用函数时包含传递参数信息的变量地址值</li></ul><h3 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join"></a>pthread_join</h3><p>调用 pthread_join 函数的进程（或线程）将进入等待状态，直到第一个参数为 ID 的线程终止为止。而且可以得到线程的 main 函数返回值，所以该函数比较有用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># include&lt;pthread.h&gt;</span><br><span class="line">int pthread_join(pthread_t thread, void ** status);</span><br></pre></td></tr></table></figure><p>→成功时返回 e，失败时返回其他值。<br>thread 该参数值 ID 的线程终止后才会从该函数返回。status 保存线程的 main 函数返回值的<br>指针变量地址值</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux C++ 多进程</title>
      <link href="/2023/07/18/CPP/LinuxC++%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
      <url>/2023/07/18/CPP/LinuxC++%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>进程是资源分配的基本单位，是程序流的基本单位</strong></p><h2 id="进程-ID"><a href="#进程-ID" class="headerlink" title="进程 ID"></a>进程 ID</h2><p>无论进程是如何创建的，所有进程都会从操作系统分配到 ID。此 ID 称为”进程 ID”，其<br>值为大于 2 的整数。1 要分配给操作系统启动后的（用于协助操作系统）首个进程，因此用<br>户进程无法得到 ID 值 1。<br>通过 ps au 指令可以查看当前运行的所有进程。令同时可以列<br>出 PID（进程 ID）。通过指定 a 和 u 参数列出了所有进程详细信息。</p><h2 id="通过调用-fork-函数创建进程"><a href="#通过调用-fork-函数创建进程" class="headerlink" title="通过调用 fork 函数创建进程"></a>通过调用 fork 函数创建进程</h2><blockquote><p>#include &lt;unistd.h&gt; pid_t fork(void); → 成功时返回进程 ID，失败时返回-1。</p></blockquote><p>fork 函数将创建调用的进程副本。也就是说，并非根据完全不同的程序创建进程，<br>而是复制正在运行的、调用 fork 函数的进程。另外，两个进程都将执行 fork 函数调用<br>后的语句（准确地说是在 fork 函数返回后）。但因为通过同一个进程、复制相同的内<br>存空间，之后的程序流要根据 fork 函数的返回值加以区分。即利用 fork 函数的如下特<br>点区分程序执行流程。 <br><br>父进程 ∶fork 函数返回子进程 ID。<br><br>子进程 ∶fork 函数返回 0。 <br><br>此处”父进程（” Parent Process）指原进程，即调用 fork 函数的主体，而”子进程（” Child<br>Process）是通过父进程调用 fork 函数复制出的进程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int gval = 10;</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    int lval = 20;</span><br><span class="line">    gval++, lval += 5;</span><br><span class="line">    pid = fork();</span><br><span class="line">    if (pid == 0)// if Child Process</span><br><span class="line">        gval += 2, lval += 2;</span><br><span class="line">    else // if Parent Process</span><br><span class="line">        gval -= 2, lval -= 2;</span><br><span class="line">    if (pid == 0)</span><br><span class="line">        printf(&quot;Child Proc: [%d, %d] \n&quot;, gval, lval);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;Parent Proc: [%d, %d] \n&quot;, gval, lval);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父子进程拥有完全独立的内存结构</p><h3 id="fork-函数产生子进程的终止方式"><a href="#fork-函数产生子进程的终止方式" class="headerlink" title="fork 函数产生子进程的终止方式"></a>fork 函数产生子进程的终止方式</h3><p>1 传递参数并调用 exit 函数。 <br><br>2 main 函数中执行 retun 语句并返回值 <br><br>向 exit 函数传递的参数值和 main 函数的 return 语句返回的值都会传递给操作系统。但是<br>操作系统不会销毁子进程，直到该子进程的父进程 return 或者 exit。处在这种状态下的进程就是僵尸进程。</p><h2 id="僵尸进程——如何销毁"><a href="#僵尸进程——如何销毁" class="headerlink" title="僵尸进程——如何销毁"></a>僵尸进程——如何销毁</h2><p>父进程调用 fork 创建子进程，子进程退出后，父进程在未退出时，操作系统不会主动销毁子进程，直到父进程退出后操作系统才会一同销毁父子进程。处于子进程退出，父进程未退出阶段的，操作系统没有主动销毁的子进程就成为了僵尸进程。</p><p>此时该子进程如果不调用 wait 或 waitpid 来获取子进程的退出信息，子进程就会沦为僵尸进程。</p><p><strong>子进程已经退出了，父进程还在运行当中，父进程没有读取到子进程的状态，子进程就会进入僵尸状态。</strong></p><p>为了销毁子进程，父进程应主动请求获取子进程的返回值。</p><h3 id="1-wait-函数"><a href="#1-wait-函数" class="headerlink" title="1.wait 函数"></a><strong>1.wait 函数</strong></h3><blockquote><p>#include&lt;sys&#x2F;wait.h&gt; pid_t wait(int* statloc); → 成功时返回终止的子进程 ID，失败时返回-1。</p></blockquote><p>调用此函数时如果已有子进程终止，那么子进程终止时传递的返回值（exit 函数的参数值、main 函数的 return 返回值）将保存到该函数的参数所指内存空间。但函数参数指向的单元中还包含其他信息，因此需要通过下列宏进行分离。</p><ol><li>WIFEXITED 子进程正常终止时返回”真”（true）。</li><li>WEXITSTATUS 返回子进程的返回值。<br>也就是说，向 wait 函数传递变量 status 的地址时，调用 wait 函数后应编写如下代码。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(WIFEXITED(status))&#123;//是正常终止的吗?</span><br><span class="line">puts(&quot;Normal termination!&quot;);</span><br><span class="line">printf（&quot;Child pass num∶%d&quot;，WEXITSTATUS（status））;&#125;//打印返回值</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int status;</span><br><span class="line">    pid_t pid = fork();</span><br><span class="line">    if (pid == 0)&#123;</span><br><span class="line">        //创建的子进程将在此行通过 main 函数中的 return 语句终止</span><br><span class="line">        sleep(30);</span><br><span class="line">        return 3;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;Child PID: %d \n&quot;, pid);</span><br><span class="line">        pid = fork();</span><br><span class="line">        if (pid == 0)&#123;</span><br><span class="line">            //创建的子进程将在此行通过调用 exit 函数终止</span><br><span class="line">            exit(7);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            printf(&quot;Child PID: %d \n&quot;, pid);</span><br><span class="line">            //调用 wait。之前终止的子进程信息将保存到 status 变量，同时相关子进</span><br><span class="line">            //程被完全销毁。</span><br><span class="line">            wait(&amp;status);</span><br><span class="line">            //通过 WIFEXITED 宏验证子进程是否正常终止。</span><br><span class="line">            //如果正常退出，则调用 WEXITSTATUS 宏输出子进程的返回值</span><br><span class="line">            if (WIFEXITED(status))</span><br><span class="line">                printf(&quot;Child send one: %d \n&quot;, WEXITSTATUS(status));</span><br><span class="line">            //因为之前创建了 2 个进程，所以再次调用 wait 函数和宏</span><br><span class="line">            wait(&amp;status);</span><br><span class="line">            if (WIFEXITED(status))</span><br><span class="line">                printf(&quot;Child send two: %d \n&quot;, WEXITSTATUS(status));</span><br><span class="line">            //为暂停父进程终止而插入的代码。此时可以查看子进程的状态</span><br><span class="line">            sleep(30); // Sleep 30 sec.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;br&gt;Child PID: 7660</span><br><span class="line">&lt;br&gt;Child PID: 7661</span><br><span class="line">&lt;br&gt;Child send one: 7</span><br><span class="line">&lt;br&gt;Child send two: 3</span><br></pre></td></tr></table></figure><p>从结果可以看出来，系统中并无上述结果中的 PID 对应的进程，。这是因为调用了 wait<br>函数，完全销毁了该进程。另外 2 个子进程终止时返回的 3 和 7 传递到了父进程。<br>**<em>调用 wait 函数时，如果没有已终止的<br>子进程，那么程序将阻塞（Blocking）直到有子进程终止</em>**，因此需谨慎调用该函数。</p><h3 id="2-waitpid-函数"><a href="#2-waitpid-函数" class="headerlink" title="2.waitpid 函数"></a>2.waitpid 函数</h3><p>wait 函数会引起程序阻塞，还可以考虑调用 waitpid 函数。这是防止僵尸进程也是防止阻塞的方法。<br>调用 waitpid 函数时，程序不会阻塞。</p><blockquote><p>#include&lt;sys&#x2F;wait.h&gt; pid_t waitpid(pid_t pid, int *statloc, int options); → 成功时返回终止的子进程 ID（或 0），失败时返回-1。</p></blockquote><ul><li>pid 等待终止的目标子进程的 ID，若传递-1，则与 wait 函数相同，可以等待任意子进<br>程终止。</li><li>statloc 与 wait 函数的 statloc 参数具有相同含义。</li><li>options 传递头文件 sys&#x2F;wait.h 中声明的常量 WNOHANG，即使没有终止的子进程也<br>不会进入阻塞状态，而是返回 0 并退出函数。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int status;</span><br><span class="line">    pid_t pid = fork();</span><br><span class="line">    if (pid == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        //调用 sleep 函数推迟子进程的执行。这会导致程序延迟 15 秒</span><br><span class="line">        sleep(15);</span><br><span class="line">        return 24;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //while 循环中调用 waitpid 函数。向第三个参数传递 WNOHANG，因此，若之前没</span><br><span class="line">        //有终止的子进程将返回 0。</span><br><span class="line">        if (!waitpid(-1, &amp;status, WNOHANG)) printf(&quot;此刻无终止的子进程\n&quot;);</span><br><span class="line">        while (!waitpid(-1, &amp;status, WNOHANG))</span><br><span class="line">        &#123;</span><br><span class="line">            sleep(3);</span><br><span class="line">            puts(&quot;sleep 3sec.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (WIFEXITED(status))</span><br><span class="line">            printf(&quot;Child send %d \n&quot;, WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 puts(“sleep 3sec.”);<br>共执行了 5 次。另外，这也证明 waitpid 函数并未阻塞。</p><h2 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h2><p>为了避免父进程调用 waitpid 函数后一直等待子进程终止。所以要在进程发现自己的子进程结束时，请求<br>操作系统调用特定函数。该请求通过 signal 函数调用完成（因此称 signal 为信号注册函数）。</p><blockquote><p>#include&lt;signal.h&gt;<br>void (*signal(int signo, void(_func)(int))) (int);<br>等价于<br>typedef void(*signal_handler)(int)<br>signal_handler signal(int signo, signal_handler func)<br>函数名 ∶signal<br>参数 ∶int signo,void(*func)(int)<br>返回类型 ∶ 参数为 int 型，返回 void 型函数指针。</p></blockquote><p>调用上述函数时，第一个参数为特殊情况信息，第二个参数为特殊情况下将要调用的函<br>数的地址值（指针）。发生第一个参数代表的情况时，调用第二个参数所指的函数。下面给<br>出可以在 signal 函数中注册的部分特殊情况和对应的常数。</p><ul><li>SIGALRM∶ 通过调用 alarm 函数注册的时间来使 os 收到该信号。</li><li>SIGINT∶ 输入 CTRL+C。</li><li>SIGCHLD∶ 子进程终止。（英文为 child）</li></ul><p><em>样例</em><br>编写调用 signal 函数的语句完成如下请求</p><ol><li>“子进程终止则调用 mychild 函数。”</li></ol><blockquote><p>signal(SIGCHLD, mychild);</p></blockquote><p>此时 mychild 函数的参数应为 int，返回值类型应为 void。对应 signal 函数的第二个参数。<br><br>另外，常数 SIGCHLD 表示子进程终止的情况，应成为 signal 函数的第一个参数。</p><ol start="2"><li>“已到通过 alarm 函数注册的时间，请调用 timeout 函数。”</li></ol><blockquote><p>signal(SIGALRM, timeout);</p></blockquote><ol start="3"><li>“输入 CTRL+C 时调用 keycontrol 函数。”</li></ol><blockquote><p>signal(SIGINT, keycontrol);</p></blockquote><p>以上就是信号注册过程。注册好信号后，发生注册信号时（注册的情况发生时），操作系统将调用该信号对应的函数</p><h3 id="alarm-函数"><a href="#alarm-函数" class="headerlink" title="alarm 函数"></a>alarm 函数</h3><p>alarm 系统调用是设置多久触发 SIGALRM 信号的函数</p><blockquote><p>#include&lt;unistd.h&gt;<br>unsigned int alarm(unsigned int seconds);→ 返回 0 或以秒为单位的距 SIGALRM 信号发生所剩时间。</p></blockquote><p>如果调用该函数的同时向它传递一个正整型参数，相应时间后（以秒为单位）将产生<br>SIGALRM 信号。若向该函数传递 0，则之前对 SIGALRM 信号的预约将取消。如果通过该函数<br>预约信号后未指定该信号对应的处理函数，则（通过调用 signal 函数）终止进程，不做任何<br>处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void signal_func(int sig) &#123;</span><br><span class="line">    switch (sig)&#123;</span><br><span class="line">    case SIGALRM:</span><br><span class="line">        printf(&quot;子线程  tid: %d, pid: %d\n&quot;, pthread_self(), getpid());</span><br><span class="line">        alarm(2);//为了每隔 2 秒重复产生 SIGALRM 信号，在信号处理器中调用 alarm 函数</span><br><span class="line">        break;</span><br><span class="line">    case SIGINT:</span><br><span class="line">        puts(&quot;CTRL+C press...\n&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">    //注册 SIGALRM、SIGINT 信号及相应处理器</span><br><span class="line">    signal(SIGALRM, signal_func);</span><br><span class="line">    signal(SIGINT, signal_func);</span><br><span class="line">    //预约 2 秒后发生 SIGALRM 信号</span><br><span class="line">    alarm(2);</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        printf(&quot;主线程  tid: %d, pid: %d\n&quot;, pthread_self(), getpid());</span><br><span class="line">        sleep(10);//信号量会对sellp休眠时间产生影响</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">主线程  tid: 1678316736, pid: 13241</span><br><span class="line">子线程  tid: 1678316736, pid: 13241</span><br><span class="line">主线程  tid: 1678316736, pid: 13241</span><br><span class="line">子线程  tid: 1678316736, pid: 13241</span><br><span class="line">主线程  tid: 1678316736, pid: 13241</span><br><span class="line">子线程  tid: 1678316736, pid: 13241</span><br><span class="line">主线程  tid: 1678316736, pid: 13241</span><br><span class="line">子线程  tid: 1678316736, pid: 13241</span><br><span class="line">主线程  tid: 1678316736, pid: 13241</span><br><span class="line">^CCTRL+C press...</span><br></pre></td></tr></table></figure><p>发生信号时将唤醒由于调用 sleep 函数而进入阻塞状态的进程。故主线程和子线程交替执行。<br>调用函数的主体的确是操作系统，但进程处于睡眠状态时无法调用函数。因此，产生信<br>号时，为了调用信号处理器，将唤醒由于调用 sleep 函数而进入阻塞状态的进程。而且，进<br>程一旦被唤醒，就不会再进入睡眠状态。即使还未到 sleep 函数中规定的时间也是如此。 所以，主程序的一个 while 循环运行不到 10 秒就会结束</p><h3 id="Sigaction-函数"><a href="#Sigaction-函数" class="headerlink" title="Sigaction 函数"></a>Sigaction 函数</h3><p>——利用 Sigaction 函数进行信号处理<br>的 signal 足以用来编写防止僵尸进程生成的代码。介绍这个更强大的 sigaction 函数，是因为 sigaction 函数类似于 signal 函数，而且完全可以代替后者，也更稳定。之所以稳定，是因为如下原因 ∶<br>“signal 在 UNIX 系列的不同操作系统中可能存在区别，但 sigaction 完全相同。” 实际上现在很少使用 signal 函数编写程序，它只是为了保持对旧程序的兼容。</p><blockquote><p>#include&lt;signal.h&gt;<br>int sigaction(int signo, const struct sigaction<em>act, struct sigaction</em>oldact);<br>→ 成功时返回 0，失败时返回-1</p></blockquote><ul><li>signo 传递信号信息。</li><li>act 对应于第一个参数的信号处理函数（信号处理器）信息。</li><li>oldact 通过此参数获取之前注册的信号处理函数指针，若不需要则传递 0。</li></ul><p>声明并初始化 sigaction 结构体变量，该结构体定义如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sigaction&#123;</span><br><span class="line">    void(*sa_handler)(int); //保存信号处理函数的指  针值（地址值）</span><br><span class="line">    sigset_t sa mask;//这 2 个成员用于指定信号相关的    选项和特性,一般初始化为 0</span><br><span class="line">    int sa_flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">void timeout(int sig)&#123;</span><br><span class="line">    if (sig == SIGALRM)</span><br><span class="line">        puts(&quot;Time out!&quot;);</span><br><span class="line">    alarm(2);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    //为了注册信号处理函数，声明 sigaction 结构体变量并在 sa_handler 成员中保</span><br><span class="line">    //存函数指针值。</span><br><span class="line">    struct sigaction act;</span><br><span class="line">    act.sa_handler = timeout;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = 0;</span><br><span class="line">    //注册 SIGALRM 信号的处理器。调用 alarm 函数预约 2 秒后发生 SIGALRM 信号。</span><br><span class="line">    sigaction(SIGALRM, &amp;act, 0);</span><br><span class="line">    alarm(2);</span><br><span class="line">    for (int i = 0; i &lt; 3; i++)&#123;</span><br><span class="line">        puts(&quot;wait...&quot;);</span><br><span class="line">        sleep(100);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用信号处理技术消灭僵尸进程"><a href="#利用信号处理技术消灭僵尸进程" class="headerlink" title="利用信号处理技术消灭僵尸进程"></a><strong>利用信号处理技术消灭僵尸进程</strong></h4><p>子进程终止时将产生 SIGCHLD 信号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">void read_childproc(int sig)</span><br><span class="line">&#123;</span><br><span class="line">    int status;</span><br><span class="line">    pid_t id = waitpid(-1, &amp;status, WNOHANG);</span><br><span class="line">    if (WIFEXITED(status))&#123;</span><br><span class="line">        printf(&quot;Removed proc id: %d \n&quot;, id);</span><br><span class="line">        printf(&quot;Child send: %d \n&quot;, WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    struct sigaction act;</span><br><span class="line">    act.sa_handler = read_childproc;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = 0;</span><br><span class="line">    //注册 SIGCHLD 信号对应的处理器。若子进程终止，则调用 read_childproc 函数。</span><br><span class="line">    //处理函数中调用了 waitpid 函数，所以子进程将正常终止，不会成为僵尸进程</span><br><span class="line">    sigaction(SIGCHLD, &amp;act, 0);</span><br><span class="line">    pid = fork();</span><br><span class="line">    if (pid == 0)&#123;</span><br><span class="line">        puts(&quot;Hi! I&#x27;m child process&quot;);</span><br><span class="line">        sleep(10);</span><br><span class="line">        return 12;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;Child proc id: %d \n&quot;, pid);</span><br><span class="line">        pid = fork();</span><br><span class="line">        if (pid == 0)&#123;</span><br><span class="line">            puts(&quot;Hi! I&#x27;m child process&quot;);</span><br><span class="line">            sleep(10);</span><br><span class="line">            exit(24);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            int i;</span><br><span class="line">            printf(&quot;Child proc id: %d \n&quot;, pid);</span><br><span class="line">            //for 循环∶为了等待发生 SIGCHLD 信号，使父进程共暂停 5 次，每次间隔 5 秒。发生</span><br><span class="line">            //信号时，父进程将被唤醒，因此实际暂停时间不到 25 秒。</span><br><span class="line">            for (i = 0; i &lt; 5; i++)&#123;</span><br><span class="line">                puts(&quot;wait...&quot;);</span><br><span class="line">                sleep(5);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Child proc id: 1629</span><br><span class="line">Hi! I&#x27;m child process</span><br><span class="line">Child proc id: 1630</span><br><span class="line">Hi! I&#x27;m child process</span><br><span class="line">wait...</span><br><span class="line">wait...</span><br><span class="line">Removed proc id: 1629</span><br><span class="line">Child send: 12</span><br><span class="line">wait...</span><br><span class="line">Removed proc id: 1630</span><br><span class="line">Child send: 24</span><br><span class="line">wait...</span><br><span class="line">wait...</span><br></pre></td></tr></table></figure><p>可以看出，子进程并未变成僵尸进程，而是正常终止了。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 如何更新软件源(阿里源、华为源、清华源等)</title>
      <link href="/2023/06/26/tips/Ubuntu%20%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0%E8%BD%AF%E4%BB%B6%E6%BA%90/"/>
      <url>/2023/06/26/tips/Ubuntu%20%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0%E8%BD%AF%E4%BB%B6%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、使用快捷键【ctrl+alt+t】打开终端。<br>2、输入以下命令备份原有软件源文件。<br>cp &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list.bak_yyyymmdd<br>3、再输入以下命令打开sources.list文件并添加新的软件源地址。<br>vim &#x2F;etc&#x2F;apt&#x2F;sources.list #打开sources.list文件</p><p>PS： 新安装的Ubuntu可能没有安装Vim, 用如下命令先安装Vim：<br>sudo apt-get install vim-gtk</p><p>在文件末尾添加新的软件源地址，常用国内源地址如下：</p><p>#阿里源地址</p><p>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic main restricted universe multiverse<br>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-proposed main restricted universe multiverse<br>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-backports main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-proposed main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> bionic-backports main restricted universe multiverse</p><p>#华为源地址</p><p>deb <a href="https://repo.huaweicloud.com/ubuntu/">https://repo.huaweicloud.com/ubuntu/</a> focal main restricted<br>deb <a href="https://repo.huaweicloud.com/ubuntu/">https://repo.huaweicloud.com/ubuntu/</a> focal-updates main restricted<br>deb <a href="https://repo.huaweicloud.com/ubuntu/">https://repo.huaweicloud.com/ubuntu/</a> focal universe<br>deb <a href="https://repo.huaweicloud.com/ubuntu/">https://repo.huaweicloud.com/ubuntu/</a> focal-updates universe<br>deb <a href="https://repo.huaweicloud.com/ubuntu/">https://repo.huaweicloud.com/ubuntu/</a> focal-backports main restricted universe<br>deb <a href="https://repo.huaweicloud.com/ubuntu/">https://repo.huaweicloud.com/ubuntu/</a> focal-security main restricted<br>deb <a href="https://repo.huaweicloud.com/ubuntu/">https://repo.huaweicloud.com/ubuntu/</a> focal-security universe</p><p>#中科大源地址</p><p>deb <a href="https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic main restricted universe multiverse<br>deb-src <a href="https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic main restricted universe multiverse<br>deb <a href="https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb-src <a href="https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb <a href="https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-backports main restricted universe multiverse<br>deb-src <a href="https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-backports main restricted universe multiverse<br>deb <a href="https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb-src <a href="https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb <a href="https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-proposed main restricted universe multiverse<br>deb-src <a href="https://mirrors.ustc.edu.cn/ubuntu/">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-proposed main restricted universe multiverse</p><p>#163源地址</p><p>deb <a href="http://mirrors.163.com/ubuntu/">http://mirrors.163.com/ubuntu/</a> bionic main restricted universe multiverse<br>deb <a href="http://mirrors.163.com/ubuntu/">http://mirrors.163.com/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb <a href="http://mirrors.163.com/ubuntu/">http://mirrors.163.com/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb <a href="http://mirrors.163.com/ubuntu/">http://mirrors.163.com/ubuntu/</a> bionic-proposed main restricted universe multiverse<br>deb <a href="http://mirrors.163.com/ubuntu/">http://mirrors.163.com/ubuntu/</a> bionic-backports main restricted universe multiverse<br>deb-src <a href="http://mirrors.163.com/ubuntu/">http://mirrors.163.com/ubuntu/</a> bionic main restricted universe multiverse<br>deb-src <a href="http://mirrors.163.com/ubuntu/">http://mirrors.163.com/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb-src <a href="http://mirrors.163.com/ubuntu/">http://mirrors.163.com/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb-src <a href="http://mirrors.163.com/ubuntu/">http://mirrors.163.com/ubuntu/</a> bionic-proposed main restricted universe multiverse<br>deb-src <a href="http://mirrors.163.com/ubuntu/">http://mirrors.163.com/ubuntu/</a> bionic-backports main restricted universe multiverse</p><p>#清华源地址</p><p>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic main restricted universe multiverse<br>deb-src <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb-src <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-backports main restricted universe multiverse<br>deb-src <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-backports main restricted universe ultiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb-src <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-proposed main restricted universe multiverse<br>deb-src <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-proposed main restricted universe ultiverse</p><p>4、输入命令更新系统软件源地址:<br>apt-get update<br>apt-get upgrade<br>————————————————<br>版权声明：本文为CSDN博主「anjoel」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/anjoel/article/details/124805571">https://blog.csdn.net/anjoel/article/details/124805571</a></p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现vmware虚拟机和主机之间的文件传输</title>
      <link href="/2023/06/26/tips/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E4%B8%BB%E6%9C%BA%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/"/>
      <url>/2023/06/26/tips/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E4%B8%BB%E6%9C%BA%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-设置共享文件夹"><a href="#1-设置共享文件夹" class="headerlink" title="1.设置共享文件夹"></a>1.设置共享文件夹</h1><p>启动虚拟机→点击虚拟机→点击设置（可以直接快捷键：Ctrl+D）<br>  在终端命令行输入如下命令：vmware-hgfsclient<br>  会显示共享文件夹<br>  输入命令：cd &#x2F;mnt&#x2F;hgfs  可进入目录查看到虚拟机中共享文件夹所在的位置。</p><h1 id="2-WinSCP"><a href="#2-WinSCP" class="headerlink" title="2.WinSCP"></a>2.WinSCP</h1><p><a href="https://blog.csdn.net/weixin_44380309/article/details/125876155">https://blog.csdn.net/weixin_44380309/article/details/125876155</a></p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>application.properties和application.yml文件的区别：</title>
      <link href="/2023/06/26/tips/application.properties%E5%92%8Capplication.yml%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/06/26/tips/application.properties%E5%92%8Capplication.yml%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="application-properties和application-yml文件的区别："><a href="#application-properties和application-yml文件的区别：" class="headerlink" title="application.properties和application.yml文件的区别："></a>application.properties和application.yml文件的区别：</h2><p>1、application.properties的优先级高于application.yml</p><p>【原因：当两者同时存在时，application.yml先执行，而application.properties后执行，后执行的application.properties文件会覆盖先执行的application.yml文件内容（只覆盖相同的内容）】</p><p>2、application.properties使用” &#x3D; “赋值，application.yml使用”  ：”赋值，且冒号与属性值之间必须有一个空格（属性:  属性值）</p><p>3、application.yml文件需要缩进时，只能使用空格键缩进，不能使用tab键</p><p>最后，application.yml文件以树型结构，其的可读性更高，结构清晰明了，建议使用application.yml<br>————————————————<br>版权声明：本文为CSDN博主「梅秃头」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_53376718/article/details/129877796">https://blog.csdn.net/qq_53376718/article/details/129877796</a></p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos 7 配置静态IP</title>
      <link href="/2023/06/26/tips/centos7%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81ip/"/>
      <url>/2023/06/26/tips/centos7%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81ip/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://blog.csdn.net/qq_35871451/article/details/130215666">https://blog.csdn.net/qq_35871451/article/details/130215666</a></p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaType 与 jdbcType对应关系：</title>
      <link href="/2023/06/26/tips/javaType%20%E4%B8%8E%20jdbcType%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/"/>
      <url>/2023/06/26/tips/javaType%20%E4%B8%8E%20jdbcType%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><pre><code>jdbcType 与 javaType 的类型对应jdbcTypejavaTypeCHARStringVARCHARStringLONGVARCHARStringNUMERICjava.math.BigDecimalDECIMALjava.math.BigDecimalBITbooleanBOOLEANbooleanTINYINTbyteSMALLINTshortINTEGERINTEGERBIGINTlongREALfloatFLOATdoubleDOUBLEdoubleBINARYbyte[]VARBINARYbyte[]LONGVARBINARYbyte[]DATEjava.sql.DateTIMEjava.sql.TimeTIMESTAMPjava.sql.TimestampCLOBClobBLOBBlobARRAYArrayDISTINCTmapping of underlying typeSTRUCTStructREFRefDATALINKjava.net.URL</code></pre>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu的一些配置命令</title>
      <link href="/2023/06/26/tips/%E8%99%9A%E6%8B%9F%E6%9C%BAubuntu%E5%88%9D%E5%A7%8B%E5%8C%96root%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/"/>
      <url>/2023/06/26/tips/%E8%99%9A%E6%8B%9F%E6%9C%BAubuntu%E5%88%9D%E5%A7%8B%E5%8C%96root%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="虚拟机ubuntu初始化root用户密码"><a href="#虚拟机ubuntu初始化root用户密码" class="headerlink" title="虚拟机ubuntu初始化root用户密码"></a>虚拟机ubuntu初始化root用户密码</h1><p>第一步：Ctrl+Alt+T打开终端 <br><br>第二步：输入命令 sudo passwd <br><br>root <br><br>输入当前用户密码 <br><br>输入所想要设置的root密码 <br><br>再次输入root密码 <br><br>第三步：输入命令su <br><br>输入root密码即切换至root用户模式下 <br></p><h1 id="ssh-配置"><a href="#ssh-配置" class="headerlink" title="ssh 配置"></a>ssh 配置</h1><p><code>sudo apt install ssh</code><br><code>sudo systemctl status ssh</code></p><p><code>sudo apt install g++ gdb make cmake</code></p><h1 id="Ubuntu如何使用root用户远程登陆"><a href="#Ubuntu如何使用root用户远程登陆" class="headerlink" title="Ubuntu如何使用root用户远程登陆"></a>Ubuntu如何使用root用户远程登陆</h1><p>这是Ubuntu系统处于安全性的考虑；</p><p>我们不能使用root用户远程连接Ubuntu系统的原因是因为，系统内的&#x2F;etc&#x2F;ssh&#x2F;sshd_config配置文件内PermitRootLogin这一行为no决定了我们无法使用root用户远程登陆，所以我们只需要更改这个配置文件的内容</p><p>输入cat &#x2F;etc&#x2F;ssh&#x2F;ssh_config命令我们可以查看这个配置文件</p><p>可以看到PermitRootLogin yes  （这里我已经从no改成yes了）</p><p>三、具体操作</p><p>1、首先我们先启动VMware里面的Ubuntu系统</p><p>使用Xshell远程连接使用普通用户登陆</p><p>2、我们先为root用户设置一个登陆密码</p><p>输入sudo passwd root</p><p>提示我们输入当前用户的密码；</p><p>之后我们给root用户设置密码；</p><p>出现passwd: password updated successfully说明成功给root用户设置了密码</p><p>3、修改配置文件</p><p>就像我们之前提到的一样，无法远程登陆是因为配置文件的设定，所以我们应该修改配置文件实现root用户的远程登陆；</p><p>输入vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config使用vim文本编辑器修改sshd_config这个配置文件</p><p>敲键盘i键进入插入模式，利用上下方向键找到PermitRootLogin的位置修改no为yes</p><p>敲键盘上的esc键退出修改，英文输入法下输入冒号键输入wq退出</p><p>4、重新启动ssh服务</p><p>上面我们已经完成了修改，此时输入命令 service ssh restart重启ssh服务即可</p><p>使用 su - root命令切换到root用户登陆</p><p>输入密码即可成功登陆</p><p>可以看到我们当前使用root用户成功登陆<br>————————————————<br>版权声明：本文为CSDN博主「蜜糖伴午茶」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/m0_63276793/article/details/134038194">https://blog.csdn.net/m0_63276793/article/details/134038194</a></p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据平台——数据中台建设实战</title>
      <link href="/2023/06/24/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E5%BB%BA%E8%AE%BE/"/>
      <url>/2023/06/24/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E5%BB%BA%E8%AE%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="大数据平台——数据中台建设实战"><a href="#大数据平台——数据中台建设实战" class="headerlink" title="大数据平台——数据中台建设实战"></a>大数据平台——数据中台建设实战</h1><p><img src="/../img/MiddlePlatformLogicalArchitecture.jpg"></p><h3 id="业务中台技术体系"><a href="#业务中台技术体系" class="headerlink" title="业务中台技术体系"></a>业务中台技术体系</h3><p>微服务：<br>服务注册与发现<br>服务配置管理<br>服务网关<br>事件&#x2F;消息总线<br>负载均衡<br>容错与熔断<br>监控与报警<br>安全和访问控制<br>日志收集与处理</p><h3 id="数据中台技术体系"><a href="#数据中台技术体系" class="headerlink" title="数据中台技术体系"></a>数据中台技术体系</h3><p>Hadoop、Spark：<br>数据采集<br>存储<br>消息队列<br>批处理<br>实时处理<br>作业调度</p><h3 id="数据中台具备的能力"><a href="#数据中台具备的能力" class="headerlink" title="数据中台具备的能力"></a>数据中台具备的能力</h3><h6 id="1-平滑自如的水平伸缩能力，从容面对海量数据"><a href="#1-平滑自如的水平伸缩能力，从容面对海量数据" class="headerlink" title="1.平滑自如的水平伸缩能力，从容面对海量数据"></a>1.平滑自如的水平伸缩能力，从容面对海量数据</h6><h6 id="2-对资源拥有细粒度的控制能力，支持多任务、多用户下的作业处理"><a href="#2-对资源拥有细粒度的控制能力，支持多任务、多用户下的作业处理" class="headerlink" title="2.对资源拥有细粒度的控制能力，支持多任务、多用户下的作业处理"></a>2.对资源拥有细粒度的控制能力，支持多任务、多用户下的作业处理</h6><h6 id="3-强大的事实处理能力"><a href="#3-强大的事实处理能力" class="headerlink" title="3.强大的事实处理能力"></a>3.强大的事实处理能力</h6><h6 id="4-参与业务请求处理的能力"><a href="#4-参与业务请求处理的能力" class="headerlink" title="4.参与业务请求处理的能力"></a>4.参与业务请求处理的能力</h6><h6 id="5-具备人工智能以及机器学习的数据分析能力"><a href="#5-具备人工智能以及机器学习的数据分析能力" class="headerlink" title="5.具备人工智能以及机器学习的数据分析能力"></a>5.具备人工智能以及机器学习的数据分析能力</h6><h6 id="6-以数据仓库理论管理和组织各类数据"><a href="#6-以数据仓库理论管理和组织各类数据" class="headerlink" title="6.以数据仓库理论管理和组织各类数据"></a>6.以数据仓库理论管理和组织各类数据</h6><h6 id="7-对外提供强大的数据服务，支持多种协议的数据传输与交互"><a href="#7-对外提供强大的数据服务，支持多种协议的数据传输与交互" class="headerlink" title="7.对外提供强大的数据服务，支持多种协议的数据传输与交互"></a>7.对外提供强大的数据服务，支持多种协议的数据传输与交互</h6><h6 id="8-拥有完善的数据治理体系，保障数据质量"><a href="#8-拥有完善的数据治理体系，保障数据质量" class="headerlink" title="8.拥有完善的数据治理体系，保障数据质量"></a>8.拥有完善的数据治理体系，保障数据质量</h6><h6 id="9-精准的细粒度安全控制"><a href="#9-精准的细粒度安全控制" class="headerlink" title="9.精准的细粒度安全控制"></a>9.精准的细粒度安全控制</h6><h3 id="集群安装过程"><a href="#集群安装过程" class="headerlink" title="集群安装过程"></a>集群安装过程</h3><h4 id="1-对每个节点做一些必要的前期处理——环境预配置"><a href="#1-对每个节点做一些必要的前期处理——环境预配置" class="headerlink" title="1.对每个节点做一些必要的前期处理——环境预配置"></a>1.对每个节点做一些必要的前期处理——环境预配置</h4><h4 id="2-安装MySql集群——安装Galera（MySQL集群），安装Redis"><a href="#2-安装MySql集群——安装Galera（MySQL集群），安装Redis" class="headerlink" title="2.安装MySql集群——安装Galera（MySQL集群），安装Redis"></a>2.安装MySql集群——安装Galera（MySQL集群），安装Redis</h4><h4 id="3-安装Cloudera-Manager，通过Cloudera-Manager安装CDH——搭建本地CDH仓库，配置CDN-server，安装CDH"><a href="#3-安装Cloudera-Manager，通过Cloudera-Manager安装CDH——搭建本地CDH仓库，配置CDN-server，安装CDH" class="headerlink" title="3.安装Cloudera Manager，通过Cloudera Manager安装CDH——搭建本地CDH仓库，配置CDN server，安装CDH"></a>3.安装Cloudera Manager，通过Cloudera Manager安装CDH——搭建本地CDH仓库，配置CDN server，安装CDH</h4><h4 id="4-对特定核心服务进行高可用配置"><a href="#4-对特定核心服务进行高可用配置" class="headerlink" title="4.对特定核心服务进行高可用配置"></a>4.对特定核心服务进行高可用配置</h4><h3 id="架构原型"><a href="#架构原型" class="headerlink" title="架构原型"></a>架构原型</h3><h4 id="1-Lambda架构"><a href="#1-Lambda架构" class="headerlink" title="1.Lambda架构"></a>1.Lambda架构</h4><p>将批处理作业和实时流处理作业分离，各自独立运行资源相互隔离<img src="/../img/MiddlePaltformLambdaArchitecture.jpg" alt="Lambda架构"></p><h5 id="Batch-Layer"><a href="#Batch-Layer" class="headerlink" title="Batch Layer"></a>Batch Layer</h5><p>主要负责所有的批处理操作，支撑技术以Hive、Spark-SQL或Map-Reduce这类批处理技术为主。对数据处理的主依赖进行维护</p><h5 id="Serving-Layer"><a href="#Serving-Layer" class="headerlink" title="Serving Layer"></a>Serving Layer</h5><p>以Batch Layer处理的结果数据为基础，对外提供低延时的数据查询和ad-hoc查询服务</p><h5 id="Speed-Layer"><a href="#Speed-Layer" class="headerlink" title="Speed Layer"></a>Speed Layer</h5><p>使用流式计算技术实时处理当前数据。只能以实时的方式处理大量数据，只能处理当前新产生的数据，无法对全部历史数据进行操作。常用Storm、Spark Streaming、Flink等大数据流计算框架 <br></p><p><strong>Lambda架构使用两条数据管道来分别用对两种场景，因此有数据冗余，健壮但是需要同时维护两套代码，增加了工作量和维护成本</strong></p><h4 id="Kappa架构"><a href="#Kappa架构" class="headerlink" title="Kappa架构"></a>Kappa架构</h4><p>对Lambda架构的一种简化使用流计算技术统一批处理和实时处理两条数据处理的pipeline <br><br>需要的技术组件：前端需要接入一个消息队列（Kafka）<br>后接流计算框架（Flink、Spark、Streaming、Storm，以流计算框架为主）</p><p><img src="/../img/MiddlePlatformKappaArchitecture.jpg" alt="Kappa架构"></p><h4 id="SMACK架构"><a href="#SMACK架构" class="headerlink" title="SMACK架构"></a>SMACK架构</h4><p>SMACK:Spark\Mesos\Akka\Cassandra\Kafka  <br><br>利用选型组件的特性，以自然和平滑的方式统一了批处理和实时处理<br><img src="/../img/MiddlePlatformSMACKArchitecture.jpg" alt="SMACK架构"><br>SAMCK架构使用Akka进行数据采集（Akka可以应对高并发和实时性要求很高的场景），然后将数据写入Kafka，接着使用Spark Streaming进行实时流处理，处理结果和原始数据都写入Cassandra，至此所有做法和Kappa架构是一样的。不同于Kappa，SMACK依然保有批处理能力，它巧妙地利用了Cassandra集群：一个集群专门用来接收流处理结果数据，另一个集群用于批处理分析，供Spark（Spark Core或 Spark SQL）读写<br><br><strong>SMACK架构之既支持批处理又支持实时处理，在数据处理层面只依赖Spack，在数据存储层面只依赖Cassandra，统一了技术堆栈</strong></p><h2 id="原型项目架构方案"><a href="#原型项目架构方案" class="headerlink" title="原型项目架构方案"></a>原型项目架构方案</h2><p><img src="/../img/MiddlePaltformArchitectureReference.jpg" alt="架构参考"></p><h3 id="1-数据采集"><a href="#1-数据采集" class="headerlink" title="1.数据采集"></a>1.数据采集</h3><p>主流工具：Flume、Logstash、Kafka Connect<br><br>数据采集组件：Apache Camel(技术选型)</p><h3 id="2-消息队列"><a href="#2-消息队列" class="headerlink" title="2.消息队列"></a>2.消息队列</h3><p>Kafka</p><h3 id="3-流处理"><a href="#3-流处理" class="headerlink" title="3.流处理"></a>3.流处理</h3><p>Storm、 Spark Streaming(技术选型)</p><h3 id="4-批处理"><a href="#4-批处理" class="headerlink" title="4.批处理"></a>4.批处理</h3><p>Hive、Spark SQL、Spark Core+Spark SQL(技术选型)</p><h3 id="5-主数据管理"><a href="#5-主数据管理" class="headerlink" title="5.主数据管理"></a>5.主数据管理</h3><p>Springboot+Mysql+Redis(技术选型)</p><h3 id="6-数据服务"><a href="#6-数据服务" class="headerlink" title="6.数据服务"></a>6.数据服务</h3><p>HBase(技术选型)、Cassandra、MongoDB</p><h3 id="7-数据展示"><a href="#7-数据展示" class="headerlink" title="7.数据展示"></a>7.数据展示</h3>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spark知识点</title>
      <link href="/2023/06/19/%E5%A4%A7%E6%95%B0%E6%8D%AE/spark/"/>
      <url>/2023/06/19/%E5%A4%A7%E6%95%B0%E6%8D%AE/spark/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="spark核心模块"><a href="#spark核心模块" class="headerlink" title="spark核心模块"></a>spark核心模块</h2><p>spark core 提供核心功能，其他功能在此基础上拓展 <br><br>spark sql 操作结构化数据的组件 <br><br>spark streaming 针对实时数据进行流式计算的组件 <br><br>spark mlib 机器学习算法库，提供模型评估、数据导入等功能和一些底层机器学习原语， <br><br>spark graphx 面向图计算提供的框架与算法库 <br></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop是一个海量数据存储和计算的平台</title>
      <link href="/2023/06/19/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop3/"/>
      <url>/2023/06/19/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hadoop是一个海量数据存储和计算的平台"><a href="#Hadoop是一个海量数据存储和计算的平台" class="headerlink" title="Hadoop是一个海量数据存储和计算的平台"></a>Hadoop是一个海量数据存储和计算的平台</h1><h4 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h4><p><img src="/../img/HadoopDistributedStorageArchitecture.png" alt="Alt text"></p><h4 id="分布式计算"><a href="#分布式计算" class="headerlink" title="分布式计算"></a>分布式计算</h4><p>移动计算：把计算程序移动到数据端进行计算<br><img src="/../img/HadoopDistributedComputing.png" alt="Alt text"></p><h2 id="三大核心组件"><a href="#三大核心组件" class="headerlink" title="三大核心组件"></a>三大核心组件</h2><h3 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h3><p>HDFS负责海量数据的分布式存储 <br><br>支持主从结构，主节点支持多个NameNode,从节点支持多个DataNode <br><br>NamdNode负责接收用户请求，维护目录系统的目录结构<br>DateNode主要负责存储数据</p><h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><p>MapReduce是一个编程模型，主要负责海量数据计算，由Map和Reduce两个阶段组成 <br><br>Map阶段是一个独立的程序，会在很多个节点同时执行，每个节点处理一部分数据 <br><br>Reduce阶段是一个单独的聚合程序</p><h3 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h3><p>Yarn负责集群资源的管理和调度，支持主从架构，主节点最多可以有两个，从节点可以有多个 <br><br>主节点（ResourceManager）进程主要负责集群资源的分配和管理 <br><br>从节点（NodeManager）主要负责单节点资源管理<br><img src="/../img/HadoopBigdataEcosystem.png" alt="Alt text"></p><h2 id="Hadoop发行版介绍"><a href="#Hadoop发行版介绍" class="headerlink" title="Hadoop发行版介绍"></a>Hadoop发行版介绍</h2><p>官方版本：Apache Hadoop 开源，集群安装维护比较麻烦 <br><br>第三方发行版本：Cloudera hadoop(CDH) 商业版，使用Cloudera Manager安装维护比较方便 <br><br>第三方发行版本：HortenWorks (HDP) 开源版，使用Ambari安装维护比较方便  <br></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qt知识点</title>
      <link href="/2023/06/08/CPP/qt/"/>
      <url>/2023/06/08/CPP/qt/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="信号与槽"><a href="#信号与槽" class="headerlink" title="信号与槽"></a>信号与槽</h2><h3 id="信号-Signal"><a href="#信号-Signal" class="headerlink" title="信号(Signal)"></a>信号(Signal)</h3><p>信号（Signal）就是在特定情况下被发射的事件，例如PushButton 最常见的信号就是鼠标单击时发射的 clicked() 信号，一个 ComboBox 最常见的信号是选择的列表项变化时发射的 CurrentIndexChanged() 信号。</p><h3 id="槽-slot"><a href="#槽-slot" class="headerlink" title="槽(slot)"></a>槽(slot)</h3><p>就是对信号响应的函数。槽就是一个函数，与一般的C++函数是一样的，可以定义在类的任何部分（public、private 或 protected），可以具有任何参数，也可以被直接调用。槽函数与一般的函数不同的是：槽函数可以与一个信号关联，当信号被发射时，关联的槽函数被自动执行。</p><h3 id="信号与槽关联是用-QObject-connect-函数实现的，其基本格式是："><a href="#信号与槽关联是用-QObject-connect-函数实现的，其基本格式是：" class="headerlink" title="信号与槽关联是用 QObject::connect() 函数实现的，其基本格式是："></a>信号与槽关联是用 QObject::connect() 函数实现的，其基本格式是：</h3><p>QObject::connect(sender, SIGNAL(signal()), receiver, SLOT(slot()));<br>参数1、信号的发送者<br>参数2、发送的信号<br>参数3、信号的接收者<br>参数4、处理函数（槽函数）</p><h2 id="对话框-模态和非模态"><a href="#对话框-模态和非模态" class="headerlink" title="对话框-模态和非模态"></a>对话框-模态和非模态</h2><p>模态对话框：不能对其他窗口进行操作<br>非模态对话框：可以对其他窗口进行操作。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows编程</title>
      <link href="/2023/05/20/CPP/windows%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/05/20/CPP/windows%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h3 id="程序三种开发方式："><a href="#程序三种开发方式：" class="headerlink" title="程序三种开发方式："></a>程序三种开发方式：</h3><p>SDK方式开发、MFC方式开发、托管方式开发<br>三种方式都是基于消息机制开发</p><h3 id="Windows数据类型"><a href="#Windows数据类型" class="headerlink" title="Windows数据类型"></a>Windows数据类型</h3><p>DWORD、DWORD32——32字节无符号整型数据<br><br>DWORD64——64字节无符号整型数据<br><br>INT、INT32、LONG32——32位符号整型数据类型<br><br>INT_PTR——指向INT类型数据的指针类型<br><br>INT64、LONG64——64位符号整型<br></p><h4 id="参数类"><a href="#参数类" class="headerlink" title="参数类"></a>参数类</h4><p>LPARAM——消息的L参数<br><br>WPARAM——消息的W参数<br><br>LPCSTR——Windows，ANSI，字符串常量<br><br>LPCTSTR——根据环境配置，如果定义了UNICODE宏，则是LPCWSTR类型，否则是LPCSTR类型<br><br>LPCWSTR——UNICODE字符串常量<br><br>LPDWORD——指向DWORD类型数据的指针<br><br>LPSTR——Window，ANSI，字符串变量<br><br>LPTSTR——根据环境配置，如果定义了UNICODE，则是LPWSTR类型，否则是LPSTR类型<br><br>LPWSTR——UNICODE字符串变量<br><br>SIZE_T——表示内存大小，以字节为单位，其最大值是CPU最大寻址范围<br><br>TCHAR——如果定义了UNICODE，则为WCHAR，否则为CHAR<br><br>WCHAR——16位Unicode字符<br></p><h4 id="句柄类"><a href="#句柄类" class="headerlink" title="句柄类"></a>句柄类</h4><p>HANDLE——对象的句柄，最基本的句柄类型<br><br>HICON——图标的句柄<br><br>HINSTANCE——程序实例的句柄<br><br>HKEY——注册表键的句柄<br><br>HMODULE——模块的句柄<br><br>HWND——窗口的句柄<br></p><table><tr><td> 前缀 </td><td>含义</td><td>前缀</td><td>含义</td></tr>    <tr><td> a </td><td>数组 array</td><td> b </td><td>布尔值 bool</td></tr>     <tr><td> by </td><td>无符号字符(字节)</td><td> c </td><td>字符(字节)</td></tr>    <tr><td> cb </td><td>字节计数</td><td> rgb </td><td>保存颜色值的长整型</td></tr>    <tr><td> cx,cy </td><td>短整型(计算x,y的长度)</td><td> dw </td><td>无符号长整型</td></tr>    <tr><td> fn </td><td>函数</td><td> h </td><td>句柄</td></tr>    <tr><td> i </td><td>整形(integer)</td><td> m_ </td><td>类的数据成员member</td></tr>    <tr><td> n </td><td>短整型或整型</td><td> np </td><td>近指针</td></tr>    <tr><td> p </td><td>指针(pointer)</td><td> l </td><td>长整型(long)</td></tr>    <tr><td> lp </td><td>长指针</td><td> s </td><td>字符串string</td></tr>    <tr><td> sz </td><td>以零结尾的字符串</td><td> tm </td><td>正文大小</td></tr>    <tr><td> w </td><td>无符号整型</td><td> x,y </td><td>无符号整型(表示x,y的坐标)</td></tr></table><h2 id="Windows消息循环"><a href="#Windows消息循环" class="headerlink" title="Windows消息循环"></a><em><strong>Windows消息循环</strong></em></h2><h3 id="消息来源："><a href="#消息来源：" class="headerlink" title="消息来源："></a>消息来源：</h3><p>操作系统产生的消息<br><br>用户触发事件消息<br><br>由消息产生消息<br></p><h3 id="消息常见定义"><a href="#消息常见定义" class="headerlink" title="消息常见定义"></a>消息常见定义</h3><h4 id="预定义消息"><a href="#预定义消息" class="headerlink" title="预定义消息"></a>预定义消息</h4><p>普通窗口消息WM<br><br>设备消息DBT<br><br>按钮消息BM<br></p><h4 id="自定义消息-WM-USER-1"><a href="#自定义消息-WM-USER-1" class="headerlink" title="自定义消息 WM_USER + 1"></a>自定义消息 WM_USER + 1</h4><h3 id="消息结构"><a href="#消息结构" class="headerlink" title="消息结构"></a>消息结构</h3><h4 id="MSG"><a href="#MSG" class="headerlink" title="MSG"></a>MSG</h4><p>窗口句柄、消息类型、高位参数、地位参数、时间、xy轴</p><h3 id="程序骨架"><a href="#程序骨架" class="headerlink" title="程序骨架"></a>程序骨架</h3><p>设计窗口类&#x3D;&gt;注册窗口类&#x3D;&gt;创建窗口&#x3D;&gt;显示以及更新窗口&#x3D;&gt;消息循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">LPCTSTR clsName = (LPCTSTR)&quot;My&quot;;</span><br><span class="line">LPCTSTR msgName = (LPCTSTR)&quot;hhhhhh&quot;;</span><br><span class="line"></span><br><span class="line">int WINAPI WinMain(</span><br><span class="line">    _In_ HINSTANCE hInstance,</span><br><span class="line">    _In_opt_ HINSTANCE hPrevInstance,</span><br><span class="line">    _In_ LPSTR lpCmdLine,</span><br><span class="line">    _In_ int nShowCmd</span><br><span class="line">) &#123;</span><br><span class="line">    //定义和配置窗口</span><br><span class="line">    WNDCLASS wndcls;</span><br><span class="line">    wndcls.cbClsExtra = NULL;</span><br><span class="line">    wndcls.cbWndExtra = NULL;</span><br><span class="line">    wndcls.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);</span><br><span class="line">    wndcls.hCursor = LoadCursor(NULL, IDC_ARROW);</span><br><span class="line">    wndcls.hIcon = LoadIcon(NULL, IDI_APPLICATION);</span><br><span class="line">    wndcls.hInstance = hInstance;</span><br><span class="line">    wndcls.lpfnWndProc = MyMinProc;</span><br><span class="line">    //定义窗口代号</span><br><span class="line">    wndcls.lpszClassName = clsName;</span><br><span class="line">    wndcls.lpszMenuName = NULL;</span><br><span class="line">    wndcls.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line"></span><br><span class="line">    //注册窗口类</span><br><span class="line">    RegisterClass(&amp;wndcls);</span><br><span class="line"></span><br><span class="line">    //创建窗口</span><br><span class="line">    HWND hwnd;</span><br><span class="line">    hwnd = CreateWindow(clsName, msgName, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hInstance, NULL);</span><br><span class="line"></span><br><span class="line">    //显示和刷新窗口</span><br><span class="line">    ShowWindow(hwnd, SW_SHOWNA);</span><br><span class="line">    UpdateWindow(hwnd);</span><br><span class="line"></span><br><span class="line">    //消息循环 GetMessage只有在接收到WM_QUIT才会返回0</span><br><span class="line">    //TranslateMessage 翻译消息WM_KEYDOWN W</span><br><span class="line">    MSG msg;</span><br><span class="line">    while (GetMessage(&amp;msg,NULL,NULL,NULL))</span><br><span class="line">    &#123;</span><br><span class="line">        TranslateMessage(&amp;msg);//消息转换</span><br><span class="line">        DispatchMessage(&amp;msg);//消息分发</span><br><span class="line">    &#125;</span><br><span class="line">    return msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line">LRESULT CALLBACK MyMinProc(</span><br><span class="line">    HWND hwnd,</span><br><span class="line">    UINT uMsg, //消息类型</span><br><span class="line">    WPARAM wParam,</span><br><span class="line">    LPARAM lParam</span><br><span class="line">) &#123;</span><br><span class="line">    //uMsg消息类型</span><br><span class="line">    int ret;</span><br><span class="line">    HDC hdc;</span><br><span class="line">    switch (uMsg) &#123;</span><br><span class="line">    case WM_CHAR:</span><br><span class="line">        char szChar[20];</span><br><span class="line">        sprintf_s(szChar, &quot;您刚才按下了：%c&quot;, wParam);</span><br><span class="line">        MessageBox(hwnd, szChar,&quot;char&quot;,NULL);</span><br><span class="line">        break;</span><br><span class="line">    case WM_LBUTTONDOWN:</span><br><span class="line">        MessageBox(hwnd, &quot;检测鼠标左键&quot;,&quot;msg&quot;,NULL);</span><br><span class="line">    case WM_PAINT:</span><br><span class="line">        PAINTSTRUCT ps;</span><br><span class="line">        hdc = BeginPaint(hwnd, &amp;ps);</span><br><span class="line">        TextOut(hdc, 0, 0, &quot;www.baidu.com&quot;, strlen(&quot;www.baidu.com&quot;));</span><br><span class="line">        EndPaint(hwnd, &amp;ps);</span><br><span class="line">        MessageBox(hwnd, &quot;重绘&quot;,&quot;msg&quot;, NULL);</span><br><span class="line">        break;</span><br><span class="line">    case WM_CLOSE:</span><br><span class="line">        ret = MessageBox(hwnd, &quot;是否真的关闭&quot;, &quot;msg&quot;, MB_YESNO);</span><br><span class="line">        if (ret = IDYES) &#123;</span><br><span class="line">            DestroyWindow(hwnd);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    case WM_DESTROY:</span><br><span class="line">        PostQuitMessage(0);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        return DefWindowProc(hwnd,  uMsg, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> int WinMain()&#123;</span><br><span class="line">    // 设计窗口外观及交互响应，注册，申请专利</span><br><span class="line">    RegisterClass(...)注册窗口类</span><br><span class="line">    CreateWindow(...)// 创建窗口</span><br><span class="line">    ShowWindow(...)// 展示窗口</span><br><span class="line">    UpdateWindow(...)// 刷新窗口</span><br><span class="line">    // 进入消息循环</span><br><span class="line">    while (GetMessage(...)) &#123;</span><br><span class="line">        TranslateMessage(...);// 消息转换</span><br><span class="line">        DispatchMessage(...);// 消息分发</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a><em><strong>网络编程</strong></em></h2>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++八股</title>
      <link href="/2023/04/15/CPP/C++%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/04/15/CPP/C++%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="C-原子变量atomic详解"><a href="#C-原子变量atomic详解" class="headerlink" title="C++原子变量atomic详解"></a>C++原子变量atomic详解</h1><p>参考列表：<a href="https://zhuanlan.zhihu.com/p/599202353">https://zhuanlan.zhihu.com/p/599202353</a> <a href="https://cplusplus.com/reference/atomic/atomic/">https://cplusplus.com/reference/atomic/atomic/</a><br><a href="https://blog.csdn.net/sinat_28305511/article/details/131257757">https://blog.csdn.net/sinat_28305511/article/details/131257757</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>C++中原子变量（atomic）是一种多线程编程中常用的同步机制，它能够确保对共享变量的操作在执行时不会被其他线程的操作干扰，从而避免竞态条件（race condition）和死锁（deadlock）等问题。<br>原子变量可以看作是一种特殊的类型，它具有类似于普通变量的操作，但是这些操作都是原子级别的，即要么全部完成，要么全部未完成。C++标准库提供了丰富的原子类型，包括整型、指针、布尔值等，使用方法也非常简单，只需要通过std::atomic&lt;T&gt;定义一个原子变量即可，其中T表示变量的类型。<br>在普通的变量中，并发的访问它可能会导致数据竞争，竞争的后果会导致操作过程不会按照正确的顺序进行操作。<br>atomic对象可以通过指定不同的memory orders来控制其对其他非原子对象的访问顺序和可见性，从而实现线程安全。常用的memory orders包括：<br>memory_order_relaxed、<br>memory_order_acquire、<br>memory_order_release、<br>memory_order_acq_rel<br>memory_order_seq_cst等。</p><h3 id="C-6种内存序"><a href="#C-6种内存序" class="headerlink" title="C++ 6种内存序"></a>C++ 6种内存序</h3><p>在多线程编程中，内存序可以帮助我们更好地控制多线程程序中的数据访问顺序。C++ 11引入了6种内存序，分别是 <code>memory_order_relaxed</code>、<code>memory_order_consume</code>、<code>memory_order_acquire</code>、<code>memory_order_release</code>、<code>memory_order_acq_rel</code> 和 <code>memory_order_seq_cst</code>。这些内存序提供了不同级别的同步保证，可以帮助我们在多线程程序中实现更精细的控制。</p><ul><li><code>memory_order_relaxed</code>: 最宽松的内存序，不提供任何同步保证。它只保证原子操作本身是原子的，但不保证操作之间的顺序。</li><li><code>memory_order_consume</code>: 消费者内存序，用于同步依赖关系。它保证了依赖于原子操作结果的后续操作将按照正确的顺序执行。</li><li><code>memory_order_acquire</code>: 获取内存序，用于同步对共享数据的访问。它保证了在获取操作之后对共享数据的所有读取操作都将看到最新的数据。</li><li><code>memory_order_release</code>: 释放内存序，用于同步对共享数据的访问。它保证了在释放操作之前对共享数据的所有写入操作都已完成，并且对其他线程可见。</li><li><code>memory_order_acq_rel</code>: 获取-释放内存序，结合了获取和释放两种内存序的特点。它既保证了获取操作之后对共享数据的所有读取操作都将看到最新的数据，又保证了在释放操作之前对共享数据的所有写入操作都已完成，并且对其他线程可见。</li><li><code>memory_order_seq_cst</code>: 顺序一致性内存序，提供了最严格的同步保证。它保证了所有线程都将看到相同的操作顺序，并且所有原子操作都将按照程序顺序执行。</li></ul><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>std::atomic::atomic</p><blockquote><p>（1）默认：使对象处于未初始化状态。 atomic() noexcept &#x3D; default;   <br><br>（2）初始化 ：使用val初始化对象。 constexpratomic (T val) noexcept; <br><br>（3）复制 [删除] ：无法复制&#x2F;移动对象。 atomic (const atomic&amp;) &#x3D; delete;</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::atmoic&lt;int&gt; count(0);</span><br></pre></td></tr></table></figure><h3 id="is-lock-free函数"><a href="#is-lock-free函数" class="headerlink" title="is_lock_free函数"></a>is_lock_free函数</h3><p>is_lock_free用于检查当前atomic对象是否支持无锁操作，调用此成员函数不会启动任何数据竞争</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool is_lock_free() const volatile noexcept;</span><br><span class="line">bool is_lock_free() const noexcept;</span><br></pre></td></tr></table></figure><h4 id="std-atomic-flag"><a href="#std-atomic-flag" class="headerlink" title="std::atomic_flag"></a>std::atomic_flag</h4><p>std::atomic_flag 是 C++ 中的一个原子布尔类型，它用于实现原子锁操作。</p><ol><li>std::atomic_flag 默认是清除状态（false）。可以使用 ATOMIC_FLAG_INIT 宏进行初始化，例如：<code>std::atomic_flag flag = ATOMIC_FLAG_INIT</code>;</li><li>std::atomic_flag 提供了两个成员函数 test_and_set() 和 clear() 来测试和设置标志位。test_and_set() 函数会将标志位置为 true，并返回之前的值；clear() 函数将标志位置为 false。</li><li>std::atomic_flag 的 test_and_set() 和 clear() 操作是原子的，可以保证在多线程环境下正确执行。</li><li>std::atomic_flag 只能表示两种状态，即 true 或 false，不能做其他比较操作。通常情况下，std::atomic_flag 被用作简单的互斥锁，而不是用来存储信息</li></ol><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;atomic&gt;</span><br><span class="line">#include&lt;thread&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">std::atomic_flag flag = ATOMIC_FLAG_INIT; //初始状态为false</span><br><span class="line">void func(int id) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Thread  &quot; &lt;&lt; id &lt;&lt; &quot; start func&quot; &lt;&lt; std::endl;</span><br><span class="line">    while (flag.test_and_set(std::memory_order_acquire)) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Thread &quot;&lt;&lt; id &lt;&lt;&quot; is waiting&quot; &lt;&lt; std::endl;</span><br><span class="line">        // 等待其他线程释放锁</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; &quot; acquired the lock.&quot; &lt;&lt; std::endl;</span><br><span class="line">    // 模拟业务处理</span><br><span class="line">    //std::this_thread::sleep_for(std::chrono::seconds(1));</span><br><span class="line">    flag.clear(std::memory_order_release);  // 释放锁</span><br><span class="line">    std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; &quot; released the lock.&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">void _test() &#123;</span><br><span class="line">    std::cout &lt;&lt; flag.test_and_set(std::memory_order_acquire) &lt;&lt; std::endl;</span><br><span class="line">    flag.clear();</span><br><span class="line">    std::cout &lt;&lt; flag.test_and_set(std::memory_order_acquire) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; flag.test_and_set(std::memory_order_acquire) &lt;&lt; std::endl;</span><br><span class="line">    //set后状态为true</span><br><span class="line">    flag.clear();</span><br><span class="line">    std::thread t1(func, 1);</span><br><span class="line">    std::thread t2(func, 2);</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">Thread  Thread  2 start func</span><br><span class="line">Thread 2 acquired the lock.</span><br><span class="line">Thread 2 released the lock.</span><br><span class="line">1 start func</span><br><span class="line">Thread 1 acquired the lock.</span><br><span class="line">Thread 1 released the lock.</span><br></pre></td></tr></table></figure><p>两个线程通过 std::atomic_flag 来争夺一个资源（即打印信息），只有一个线程能够获得锁，执行相应的操作。另一个线程需要等待锁被释放才能继续执行。使用test_and_set() 和 clear() 函数来测试和设置标志位，保证这些操作是原子的。</p><h3 id="store函数"><a href="#store函数" class="headerlink" title="store函数"></a>store函数</h3><p>std::atomic<T>::store()用于将给定的值存储到原子对象中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void store(T desired, std::memory_order order = std::memory_order_seq_cst) volatile noexcept;</span><br><span class="line">void store(T desired, std::memory_order order = std::memory_order_seq_cst) noexcept;</span><br></pre></td></tr></table></figure><ul><li><code>desired</code>：要存储的值。</li><li><code>order</code>：存储操作的内存顺序。默认是std::memory_order_seq_cst（顺序一致性）<br>存储操作的内存顺序参数：<table><thead><tr><th>value</th><th>内存顺序</th><th>描述</th></tr></thead><tbody><tr><td>memory_order_relaxed</td><td>无序的内存访问</td><td>不做任何同步，仅保证该原子类型变量的操作是原子化的，并不保证其对其他线程的可见性和正确性。</td></tr><tr><td>memory_order_consume</td><td>与消费者关系有关的顺序</td><td>保证本次读取之前所有依赖于该原子类型变量值的操作都已经完成，但不保证其他线程对该变量的存储结果已经可见。</td></tr><tr><td>memory_order_acquire</td><td>获取关系的顺序</td><td>保证本次读取之前所有先于该原子类型变量写入内存的操作都已经完成，并且其他线程对该变量的存储结果已经可见。</td></tr><tr><td>memory_order_seq_cst</td><td>顺序一致性的顺序</td><td>保证本次操作以及之前和之后的所有原子操作都按照一个全局的内存顺序执行，从而保证多线程环境下对变量的读写的正确性和一致性。这是最常用的内存顺序。</td></tr><tr><td>memory_order_release</td><td>释放关系的顺序</td><td>保证本次写入之后所有后于该原子类型变量写入内存的操作都已经完成，并且其他线程可以看到该变量的存储结果。</td></tr><tr><td><em>详见简介 C++6种内存序</em></td><td></td><td></td></tr><tr><td>示例</td><td></td><td></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;int&gt; atomic_int(0);</span><br><span class="line">std::cout &lt;&lt; &quot;Value stored in atomic object: &quot; &lt;&lt; atomic_int &lt;&lt; std::endl;</span><br><span class="line">int val = 10;</span><br><span class="line">atomic_int.store(val); //默认memory_order_seq_cst 顺序一致性</span><br><span class="line">std::cout &lt;&lt; &quot;Value stored in atomic object: &quot; &lt;&lt; atomic_int &lt;&lt; std::endl;</span><br><span class="line">val = 5;</span><br><span class="line">atomic_int.store(val);</span><br><span class="line">std::cout &lt;&lt; &quot;Value stored in atomic object: &quot; &lt;&lt; atomic_int &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Value stored in atomic object: 0</span><br><span class="line">Value stored in atomic object: 10</span><br><span class="line">Value stored in atomic object: 5</span><br></pre></td></tr></table></figure>在多线程环境下使用原子变量和操作时，需要使用适当的内存顺序来保证数据的正确性和一致性。因此，store()函数中的order参数可以用来指定不同的内存顺序。如果不确定如何选择内存顺序，请使用默认值std::memory_order_seq_cst，它是最常用和最保险的。</li></ul><h3 id="load函数"><a href="#load函数" class="headerlink" title="load函数"></a>load函数</h3><p>load函数用于获取原子变量的当前值。它有以下两种形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T load(memory_order order = memory_order_seq_cst) const noexcept;</span><br><span class="line">operator T() const noexcept;</span><br></pre></td></tr></table></figure><p>其中，第一种形式是显式调用load函数，第二种形式是通过重载类型转换运算符实现隐式调用。<br>load函数的参数memory_order表示内存序，也就是对原子变量的读操作要遵循哪种内存模型。C++中定义了多种内存序，包括：</p><ul><li>memory_order_relaxed：最轻量级的内存序，不提供任何同步机制。</li><li>memory_order_acquire：在本线程中，所有后面的读写操作必须在这个操作之后执行。</li><li>memory_order_release：在本线程中，该操作之前的所有读写操作必须在这个操作之前执行。 </li><li>memory_order_seq_cst：最严格的内存序，保证所有线程看到的读写操作的顺序都是一致的。</li></ul><p>使用load函数时，如果不指定memory_order，则默认为memory_order_seq_cst。 <br><br>load函数的返回值类型为T，即原子变量的类型。在使用load函数时需要指定类型参数T。如果使用第二种形式的load函数，则无需指定类型参数T，程序会自动根据上下文推断出类型。<br>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;int&gt; atomic_int(10);</span><br><span class="line">int x = atomic_int.load(std::memory_order_relaxed); // get value atomically</span><br><span class="line">int xx = int(atomic_int.load());</span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; xx &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h3 id="exchange函数"><a href="#exchange函数" class="headerlink" title="exchange函数"></a>exchange函数</h3><p>访问和修改包含的值，将包含的值替换并返回它前面的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt; class T &gt;</span><br><span class="line">T exchange( volatile std::atomic&lt;T&gt;* obj, T desired );</span><br></pre></td></tr></table></figure><p>其中，obj参数指向需要替换值的atomic对象，desired参数为期望替换成的值。如果替换成功，则返回原来的值。<br>整个操作是原子的（原子读-修改-写操作）：从读取（要返回）值的那一刻到此函数修改值的那一刻，该值不受其他线程的影响。<br>用例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;bool&gt; ready(false);</span><br><span class="line">std::atomic&lt;bool&gt; winner(false);</span><br><span class="line">void count1m(int id) &#123;</span><br><span class="line">    while (!ready) &#123;&#125;                  // wait for the ready signal</span><br><span class="line">    for (int i = 0; i &lt; 1000000; ++i) &#123;&#125;   // go!, count to 1 million</span><br><span class="line">    if (!winner.exchange(true)) &#123; std::cout &lt;&lt; &quot;thread #&quot; &lt;&lt; id &lt;&lt; &quot; won!\n&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void _test() &#123;</span><br><span class="line">    //exchange</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    std::cout &lt;&lt; &quot;spawning 10 threads that count to 1 million...\n&quot;;</span><br><span class="line">    for (int i = 1; i &lt;= 10; ++i) threads.push_back(std::thread(count1m, i));</span><br><span class="line">    ready = true;</span><br><span class="line">    for (auto&amp; th : threads) th.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread #6 won!</span><br></pre></td></tr></table></figure><h3 id="compare-exchange-weak函数"><a href="#compare-exchange-weak函数" class="headerlink" title="compare_exchange_weak函数"></a>compare_exchange_weak函数</h3><p>这个函数的作用是比较一个值和一个期望值是否相等，如果相等则将该值替换成一个新值，并返回true；否则不做任何操作并返回false。</p><blockquote><p>bool compare_exchange_weak (T&amp; expected, T val,memory_order sync &#x3D; memory_order_seq_cst) volatile noexcept;<br>bool compare_exchange_weak (T&amp; expected, T val,memory_order sync &#x3D; memory_order_seq_cst) noexcept;<br>bool compare_exchange_weak (T&amp; expected, T val,memory_order success, memory_order failure) volatile noexcept;<br>bool compare_exchange_weak (T&amp; expected, T val,memory_order success, memory_order failure) noexcept;<br>参数说明</p></blockquote><ul><li>expected：期望值的地址，也是输入参数，表示要比较的值；</li><li>val：新值，也是输入参数，表示期望值等于该值时需要替换的值；</li><li>success：表示函数执行成功时内存序的类型，默认为memory_order_seq_cst；</li><li>failure：表示函数执行失败时内存序的类型，默认为memory_order_seq_cst。<br>该函数的返回值为bool类型，表示操作是否成功。<br>注意，compare_exchange_weak函数是一个弱化版本的原子操作函数，因为在某些平台上它可能会失败并重试。如果需要保证严格的原子性，则应该使用compare_exchange_strong函数。<br>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;       // std::cout</span><br><span class="line">#include &lt;atomic&gt;         // std::atomic</span><br><span class="line">#include &lt;thread&gt;         // std::thread</span><br><span class="line">#include &lt;vector&gt;         // std::vector</span><br><span class="line">// a simple global linked list:</span><br><span class="line">struct Node &#123; int value; Node* next; &#125;;</span><br><span class="line">std::atomic&lt;Node*&gt; list_head (nullptr);</span><br><span class="line">void append (int val) &#123;     // append an element to the list</span><br><span class="line">  Node* oldHead = list_head;</span><br><span class="line">  Node* newNode = new Node &#123;val,oldHead&#125;;</span><br><span class="line">  // what follows is equivalent to: list_head = newNode, but in a thread-safe way:</span><br><span class="line">  while (!list_head.compare_exchange_weak(oldHead,newNode))</span><br><span class="line">    newNode-&gt;next = oldHead;</span><br><span class="line">&#125;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">  // spawn 10 threads to fill the linked list:</span><br><span class="line">  std::vector&lt;std::thread&gt; threads;</span><br><span class="line">  for (int i=0; i&lt;10; ++i) threads.push_back(std::thread(append,i));</span><br><span class="line">  for (auto&amp; th : threads) th.join();</span><br><span class="line">  // print contents:</span><br><span class="line">  for (Node* it = list_head; it!=nullptr; it=it-&gt;next)</span><br><span class="line">    std::cout &lt;&lt; &#x27; &#x27; &lt;&lt; it-&gt;value;</span><br><span class="line">  std::cout &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">  // cleanup:</span><br><span class="line">  Node* it; while (it=list_head) &#123;list_head=it-&gt;next; delete it;&#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="compare-exchange-strong函数"><a href="#compare-exchange-strong函数" class="headerlink" title="compare_exchange_strong函数"></a>compare_exchange_strong函数</h3><p>这个函数的作用和compare_exchange_weak类似，都是比较一个值和一个期望值是否相等，并且在相等时将该值替换成一个新值。不同的是，compare_exchange_strong会保证原子性，并且如果比较失败则会返回当前值。</p><blockquote><p>bool compare_exchange_strong(T&amp; expected, T desired,<br>                             memory_order success &#x3D; memory_order_seq_cst,<br>                             memory_order failure &#x3D; memory_order_seq_cst) noexcept;</p></blockquote><ul><li>expected：期望值的地址，也是输入参数，表示要比较的值；</li><li>desired：新值，也是输入参数，表示期望值等于该值时需要替换的值；</li><li>success：表示函数执行成功时内存序的类型，默认为memory_order_seq_cst；</li><li>failure：表示函数执行失败时内存序的类型，默认为memory_order_seq_cst。<br>该函数的返回值为bool类型，表示操作是否成功。<br>注意，compare_exchange_strong函数保证原子性，因此它的效率可能比compare_exchange_weak低。在使用时应根据具体情况选择适合的函数。</li></ul><h3 id="专业化支持的操作"><a href="#专业化支持的操作" class="headerlink" title="专业化支持的操作"></a>专业化支持的操作</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>fetch_add</td><td>添加到包含的值并返回它在操作之前具有的值</td></tr><tr><td>fetch_sub</td><td>从包含的值中减去，并返回它在操作之前的值</td></tr><tr><td>fetch_and</td><td>读取包含的值，并将其替换为在读取值和 之间执行按位 AND 运算的结果</td></tr><tr><td>fetch_or</td><td>读取包含的值，并将其替换为在读取值和 之间执行按位 OR 运算的结果</td></tr><tr><td>fetch_xor</td><td>读取包含的值，并将其替换为在读取值和 之间执行按位 XOR 运算的结果</td></tr><tr><td>使用示例</td><td></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// atomic::load/store example</span><br><span class="line">#include &lt;iostream&gt; // std::cout</span><br><span class="line">#include &lt;atomic&gt; // std::atomic, std::memory_order_relaxed</span><br><span class="line">#include &lt;thread&gt; // std::thread</span><br><span class="line">//std::atomic&lt;int&gt; count = 0;//错误初始化</span><br><span class="line">std::atomic&lt;int&gt; count(0); // 准确初始化</span><br><span class="line">void set_count(int x)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; &quot;set_count:&quot; &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">count.store(x, std::memory_order_relaxed); // set value atomically</span><br><span class="line">&#125;</span><br><span class="line">void print_count()</span><br><span class="line">&#123;</span><br><span class="line">int x;</span><br><span class="line">do &#123;</span><br><span class="line">x = count.load(std::memory_order_relaxed); // get value atomically</span><br><span class="line">&#125; while (x==0);</span><br><span class="line">std::cout &lt;&lt; &quot;count: &quot; &lt;&lt; x &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">std::thread t1 (print_count);</span><br><span class="line">std::thread t2 (set_count, 10);</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line">std::cout &lt;&lt; &quot;main finish\n&quot;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>原子操作在多线程中可以保证线程安全，而且效率会比互斥量好些。<br>原子变量支持的基本操作有：</p><ul><li>加法：a +&#x3D; n或者a.fetch_add(n)</li><li>减法：a -&#x3D; n或者a.fetch_sub(n)</li><li>与、或、异或运算：a &amp;&#x3D; b、a |&#x3D; b、a ^&#x3D; b或者a.fetch_and(b)、a.fetch_or(b)、a.fetch_xor(b)</li><li>自增、自减运算：++a、–a、a++、a–或者a.fetch_add(1)、a.fetch_sub(1)</li><li>交换：a.exchange(b)返回原来的值，将a设置为b</li><li>比较并交换：a.compare_exchange_strong(b, c)或者a.compare_exchange_weak(b, c)，如果a的值等于b，则将a设置为c，返回true，否则返回false。<br>尽管原子变量是多线程编程中非常重要的同步机制，但是它也存在一些局限性。具体来说，原子变量只能保证单个变量的原子性操作，而不能保证多个变量之间的同步。此外，原子变量也无法解决数据竞争（data race）等问题，因此在使用时需要注意避免这些问题的出现。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
